#+TITLE: Leetcode Problems
#+AUTHOR: Marvin
#+PROPERTY: LOGGING nil

* 001 Two Sum :Array:HashTable:
:PROPERTIES:
:Difficulty: Easy
:END:
** Problem

Given an array of integers, return *indices* of the two numbers such that they
add up to a specific target.

You may assume that each input would have *exactly* one solution, and you may
not use the same element twice.

*Example*
#+BEGIN_EXAMPLE
Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,

return [0, 1].
#+END_EXAMPLE

** Solution
*** Brute Force
We can easily have a quick solution based on brute force way - two level nested
loops.

Pseudo code:
1. Outer loop, record index as =i=
2. Innser loop, record index as =j=
   - compare =targe= and =nums[i]+nums[j]=
   - if equal, exit the loop, return =i= & =j=
   - else, continue the loop

The time complexity of the brute force way is O(n^2), which is not good.
*** Hashmap
We can then have an idea that there's no need for two loops, if we can have a
hashmap of the numbers, we just need one loop, with =target-currentNumber=, we
can immediately get the index of second number. We only need 2n as for time
complexity. The first time of loop is to build the hashmap, we then have the
second loop to compare the target and retrieve the indices.

Pseudo code:
1. First loop - build hashmap with key equal to number and value to index
2. Second loop - let =taget_num = target - nums[i]=, retrieve second index from
   the hashmap, if =map[target_numer]= exist, then return it as second index,
   else continue the loop.

The time complexity is O(n)

*** Improved Hashmap
We then come with the idea that there's no need to prebuid the hashmap, we could
combine the building of hashmap and search target within exact one loop, the
performance then could be further improved.

Pseudo code:
1. Build am empty hashmap =map=
2. Within the loop of nums
   - let =target_num = target - nums[i]=
   - Check if target-num exist in map, return indices if exist
   - if not, put current value and index into the map.

* 002 Add Two Numbers :LinkedList:
:PROPERTIES:
:Difficulty: Medium
:END:
** Problem

You are given two non-empty linked lists representing two non-negative integers.
The digits are stored in reverse order and each of their nodes contain a single
digit. Add the two numbers and return it as a linked list.


You may assume the two numbers do not contain any leading zero, except the
number 0 itself.

*Example*
#+BEGIN_EXAMPLE
Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)

Output: 7 -> 0 -> 8

Explanation: 342 + 465 = 807.
#+END_EXAMPLE

** Solution
This problem is relatively simply if you are familiar with the basic data
structure linked list.

Just need to visit two linked list, have them sum up, in the meantime, need to
care about whether one of the linked list is empty, and whether the sum in each
time is bigger than 9.
* 003 Longest Substring :String:TwoPointers:
:PROPERTIES:
:Difficulty: Medium
:END:
** Problem
Given a string, find the length of the longest substring without repeating characters.
*Example 1*
#+BEGIN_EXAMPLE
Input: "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
#+END_EXAMPLE

*Example 2*
#+BEGIN_EXAMPLE
Input: "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
#+END_EXAMPLE

*Example 3*
#+BEGIN_EXAMPLE
Input: "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Note that the answer must be a substring, "pwke" is a subsequence and not a substring.
#+END_EXAMPLE

** Solution
A typical two pointer or slide window problem.
The algorithm describes in below:
1. Define front pointer fp at position 0, define back pointer bp at position 0.
2. Check whether next character of fp has repeat character between fp and bp.
3. If not, move fp forward; And back to step 2
4. If yes,
   - compare current string length with already saved maximum string, if
     exceeds, then save current string to maxmum string
   - move bp to next character of the repeat character
   - move fp to next character, and back to step 2

The tricky part is how to detect whether the next character is repeat between bp
and fp, we could build a hash map to store the characters between bp and fp with
its position, so that the check time is constant. In this case, the space
complexity is O(n) time complexity is n,
* 004 Median of Two Sorted Arrays :Array:BinarySearch:DivedAndConquer:
:PROPERTIES:
:Difficulty: Hard
:Link:     https://leetcode.com/problems/median-of-two-sorted-arrays/
:END:
** Problem
There are two sorted arrays nums1 and nums2 of size m and n respectively.

Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

You may assume nums1 and nums2 cannot be both empty.

*Example 1:*
#+BEGIN_EXAMPLE
nums1 = [1, 3]
nums2 = [2]

The median is 2.0
#+END_EXAMPLE

*Example 2:*
#+BEGIN_EXAMPLE
nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5
#+END_EXAMPLE

** Solution
The straight forward idea is to repeatly minus the divisor from dividend according to definition of division. It surely works, the time complexity is n(divisor/dividend).

We can, somehow, think about that with repeatly do the step of ~let sum=divide, do sum += sum~, we could accelarate the minus. The next question is how we count how many times we've done the minus, answer is we setup another synced stack to calculate the repeat double of *one*. So that when we finish the minus, we just need to check the stack of *one*, and sum all of them.

*Pseudo code*:
1. Build a two dimension array, the initial two values are 1 & divide.
2. Double previous two values via plus the same, compare the doubled divide stack with dividend.
3. If less than dividend then store it in next array position. Continue with step 2.
4. Else, compare current (before doubled) divide value, check if < dividend.
5. If Yes, divident -= current summed divide value, array backwards one, sum the index stack
6. Else, array backwards one and continue with step 3

With step 4 - 6, the loop end condition should be dividend < divide.
Exception Case:
1. Dividend and divisor could be negative
2. Could be overflow during calcualtion.

* 005 Longest Palindromic Substring
:PROPERTIES:
:Difficulty: Medium
:END:
** Problem
Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.
*Example 1*
#+BEGIN_EXAMPLE
Input: "babad"
Output: "bab"
Note: "aba" is also a valid answer.
#+END_EXAMPLE

*Example 2*
#+BEGIN_EXAMPLE
Input: "cbbd"
Output: "bb"
#+END_EXAMPLE

** Solution
* 006 ZigZag Conversion
:PROPERTIES:
:Difficulty: Medium
:END:
** Problem
The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

P   A   H   N
A P L S I I G
Y   I   R
And then read line by line: "PAHNAPLSIIGYIR"

Write the code that will take a string and make this conversion given a number of rows:

string convert(string s, int numRows);
*Example 1*
#+BEGIN_EXAMPLE
Input: s = "PAYPALISHIRING", numRows = 3
Output: "PAHNAPLSIIGYIR"
#+END_EXAMPLE

*Example 2*
#+BEGIN_EXAMPLE
Input: s = "PAYPALISHIRING", numRows = 4
Output: "PINALSIGYAHRPI"
Explanation:

P     I    N
A   L S  I G
Y A   H R
P     I
#+END_EXAMPLE


** Solution
* 007 Reverse Integer :Math:
:PROPERTIES:
:Difficulty: Easy
:END:
** Problem
Given a 32-bit signed integer, reverse digits of an integer.

*Example 1*
#+BEGIN_EXAMPLE
Input: 123
Output: 321
Example 2:
#+END_EXAMPLE

*Example 2*
#+BEGIN_EXAMPLE
Input: 120
Output: 21
#+END_EXAMPLE

Note:
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.
* 008 String to Integer (atoi)
:PROPERTIES:
:Difficulty: Medium
:END:
** Problem
Implement atoi which converts a string to an integer.

The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.

The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.

If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.

If no valid conversion could be performed, a zero value is returned.

*Note*:

Only the space character ' ' is considered as whitespace character.
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.

*Example 1*:
#+BEGIN_EXAMPLE
Input: "42"
Output: 42
#+END_EXAMPLE

*Example 2*:
#+BEGIN_EXAMPLE
Input: "   -42"
Output: -42
Explanation: The first non-whitespace character is '-', which is the minus sign.
             Then take as many numerical digits as possible, which gets 42.
#+END_EXAMPLE

*Example 3*:
#+BEGIN_EXAMPLE
Input: "4193 with words"
Output: 4193
Explanation: Conversion stops at digit '3' as the next character is not a numerical digit.
#+END_EXAMPLE

*Example 4*:
#+BEGIN_EXAMPLE
Input: "words and 987"
Output: 0
Explanation: The first non-whitespace character is 'w', which is not a numerical
             digit or a +/- sign. Therefore no valid conversion could be performed.
#+END_EXAMPLE

*Example 5*:
#+BEGIN_EXAMPLE
Input: "-91283472332"
Output: -2147483648
Explanation: The number "-91283472332" is out of the range of a 32-bit signed integer.
             Thefore INT_MIN (−231) is returned.
#+END_EXAMPLE
** Solution

* 009 Palindrome Number :Math:
:PROPERTIES:
:Difficulty: Easy
:END:
** Problem
Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.

*Example 1:*
#+BEGIN_EXAMPLE
Input: 121
Output: true
#+END_EXAMPLE

*Example 2:*
#+BEGIN_EXAMPLE
Input: -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
#+END_EXAMPLE

*Example 3:*
#+BEGIN_EXAMPLE
Input: 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.
#+END_EXAMPLE
** Solution
* 010 Regular Expression Matching :String:DP:Backtracking:
:PROPERTIES:
:Difficulty: Hard
:END:
** Problem
Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'.

'.' Matches any single character.
'*' Matches zero or more of the preceding element.
The matching should cover the entire input string (not partial).

Note:

s could be empty and contains only lowercase letters a-z.
p could be empty and contains only lowercase letters a-z, and characters like . or *.
Example 1:
#+BEGIN_EXAMPLE
Input:
s = "aa"
p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input:
s = "aa"
p = "a*"
Output: true
Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE
Input:
s = "ab"
p = ".*"
Output: true
Explanation: ".*" means "zero or more (*) of any character (.)".
#+END_EXAMPLE

Example 4:
#+BEGIN_EXAMPLE
Input:
s = "aab"
p = "c*a*b"
Output: true
Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches "aab".
#+END_EXAMPLE

Example 5:
#+BEGIN_EXAMPLE
Input:
s = "mississippi"
p = "mis*is*p*."
Output: false
#+END_EXAMPLE

** Solution
* 011 Container With Most Water :Array:TwoPointers:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/container-with-most-water/][leetcode]]
:END:
** Problem
Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.

*Note*: You may not slant the container and n is at least 2.


The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.

Example:
#+BEGIN_EXAMPLE
Input: [1,8,6,2,5,4,8,3,7]
Output: 49
#+END_EXAMPLE
* 012 Integer to Roman :Math:String:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/integer-to-roman/][leetcode]]
:END:
** Problem
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9.
X can be placed before L (50) and C (100) to make 40 and 90.
C can be placed before D (500) and M (1000) to make 400 and 900.
Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.

Example 1:
#+BEGIN_EXAMPLE
Input: 3
Output: "III"
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: 4
Output: "IV"
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE
Input: 9
Output: "IX"
#+END_EXAMPLE

Example 4:
#+BEGIN_EXAMPLE
Input: 58
Output: "LVIII"
Explanation: L = 50, V = 5, III = 3.
#+END_EXAMPLE

Example 5:
#+BEGIN_EXAMPLE
Input: 1994
Output: "MCMXCIV"
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
#+END_EXAMPLE

* 013 Roman to Integer :Math:String:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/roman-to-integer/][leetcode]]
:END:
** Problem
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
#+BEGIN_QUOTE
Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
#+END_QUOTE

For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9.
X can be placed before L (50) and C (100) to make 40 and 90.
C can be placed before D (500) and M (1000) to make 400 and 900.
Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.

Example 1:
#+BEGIN_EXAMPLE
Input: "III"
Output: 3
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: "IV"
Output: 4
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE
Input: "IX"
Output: 9
#+END_EXAMPLE

Example 4:
#+BEGIN_EXAMPLE
Input: "LVIII"
Output: 58
Explanation: L = 50, V= 5, III = 3.
#+END_EXAMPLE

Example 5:
#+BEGIN_EXAMPLE
Input: "MCMXCIV"
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
#+END_EXAMPLE
* 014 Longest Common Prefix :String:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/longest-common-prefix/][leetcode]]
:END:
** Problem
Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string "".

Example 1:
#+BEGIN_EXAMPLE
Input: ["flower","flow","flight"]
Output: "fl"
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: ["dog","racecar","car"]
Output: ""
Explanation: There is no common prefix among the input strings.
#+END_EXAMPLE

*Note:*

All given inputs are in lowercase letters ~a-z~.
* 017 Letter Combinations of a Phone Number
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/letter-combinations-of-a-phone-number/submissions/][leetcode]]
:END:
** Problem :ATTACH:
:PROPERTIES:
:ID:       a0385b12-e7a1-4e57-9225-5058ad4afed1
:END:
Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.

A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.

[[attachment:_20201011_134915screenshot.png]]


Example 1:

Input: digits = "23"
Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"]
Example 2:

Input: digits = ""
Output: []
Example 3:

Input: digits = "2"
Output: ["a","b","c"]


Constraints:

0 <= digits.length <= 4
digits[i] is a digit in the range ['2', '9'].

* 029 Divide Two Integers :BinarySearch:
:PROPERTIES:
:Difficulty: Medium
:END:
** Problem
Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.

Return the quotient after dividing dividend by divisor.

The integer division should truncate toward zero, which means losing its fractional part. For example, truncate(8.345) = 8 and truncate(-2.7335) = -2.
*Example 1*
#+BEGIN_EXAMPLE
Input: dividend = 10, divisor = 3
Output: 3
Explanation: 10/3 = truncate(3.33333..) = 3.
#+END_EXAMPLE

*Example 2*
#+BEGIN_EXAMPLE
Input: dividend = 7, divisor = -3
Output: -2
Explanation: 7/-3 = truncate(-2.33333..) = -2.
#+END_EXAMPLE

** Solution
* 032 Longest Valid Parentheses :String:DP:
:PROPERTIES:
:Difficulty: Hard
:Link:    [[https://leetcode.com/problems/longest-valid-parentheses/][leetcode]]
:END:
** Problem
Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.

Example 1:
#+BEGIN_EXAMPLE
Input: "(()"
Output: 2
Explanation: The longest valid parentheses substring is "()"
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: ")()())"
Output: 4
Explanation: The longest valid parentheses substring is "()()"
#+END_EXAMPLE
* 034 Find First and Last Position of Element in Sorted Array :BinarySearch:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/][leetcode]]
:END:
** Problem
Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.

If target is not found in the array, return [-1, -1].

Follow up: Could you write an algorithm with O(log n) runtime complexity?

Example 1:
#+BEGIN_EXAMPLE
Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE
Input: nums = [], target = 0
Output: [-1,-1]
#+END_EXAMPLE

*Constraints:*
- 0 <= nums.length <= 10^5
- -10^9 <= nums[i] <= 10^9
- nums is a non-decreasing array.
- -10^9 <= target <= 10^9
* 037 Sudoku Solver :Backtracking:
:PROPERTIES:
:Difficulty: Hard
:Link:     [[https://leetcode.com/problems/sudoku-solver/description/][leetcode]]
:END:
** Problem :ATTACH:
:PROPERTIES:
:ID:       99be855e-e4f3-402c-a1e7-97b460b51aae
:END:
Write a program to solve a Sudoku puzzle by filling the empty cells.

A sudoku solution must satisfy all of the following rules:

Each of the digits 1-9 must occur exactly once in each row.
Each of the digits 1-9 must occur exactly once in each column.
Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.
The '.' character indicates empty cells.

Example 1:
#+BEGIN_EXAMPLE
Input: board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]
Output: [["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]
Explanation: The input board is shown above and the only valid solution is shown below:
#+END_EXAMPLE
[[attachment:_20201018_102456screenshot.png]]

[[attachment:_20201018_102508screenshot.png]]

*Constraints:*
- board.length == 9
- board[i].length == 9
- board[i][j] is a digit or '.'.
- It is guaranteed that the input board has only one solution.
* 039 Combination Sum :Backtracking:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/combination-sum/description/][leetcode]]
:END:
** Problem
Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.

The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.

It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.



Example 1:
#+BEGIN_EXAMPLE
Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]
Explanation:
2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.
7 is a candidate, and 7 = 7.
These are the only two combinations.
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: candidates = [2,3,5], target = 8
Output: [[2,2,2,2],[2,3,3],[3,5]]
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE
Input: candidates = [2], target = 1
Output: []
#+END_EXAMPLE

Example 4:
#+BEGIN_EXAMPLE
Input: candidates = [1], target = 1
Output: [[1]]
#+END_EXAMPLE

Example 5:
#+BEGIN_EXAMPLE
Input: candidates = [1], target = 2
Output: [[1,1]]
#+END_EXAMPLE

*Constraints:*
- 1 <= candidates.length <= 30
- 1 <= candidates[i] <= 200
- All elements of candidates are distinct.
- 1 <= target <= 500
* 040 Combination Sum II :Backtracking:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/combination-sum-ii/description/][leetcode]]
:END:
** Problem
Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.

Each number in candidates may only be used once in the combination.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
Example 1:
#+BEGIN_EXAMPLE
Input: candidates = [10,1,2,7,6,1,5], target = 8,
A solution set is:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: candidates = [2,5,2,1,2], target = 5,
A solution set is:
[
  [1,2,2],
  [5]
]
#+END_EXAMPLE

* 046 Permutations :Backtracking:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/permutations/description/][leetcode]]
:END:
** Problem
Given a collection of distinct integers, return all possible permutations.

Example:
#+BEGIN_EXAMPLE
Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
#+END_EXAMPLE

* 047 Permutations II :Backtracking:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/permutations-ii/description/][leetcode]]
:END:
** Problem
Given a collection of numbers that might contain duplicates, return all possible unique permutations.

Example:
#+BEGIN_EXAMPLE
Input: [1,1,2]
Output:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
#+END_EXAMPLE
* 051 N-Queens :Backtracking:
:PROPERTIES:
:Difficulty: Hard
:Link:     [[https://leetcode.com/problems/n-queens/description/][leetcode]]
:END:
** Problem :ATTACH:
:PROPERTIES:
:ID:       e563448f-f67f-4e60-9998-d0515116faf1
:END:
The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.

[[attachment:_20201018_125500screenshot.png]]

Given an integer n, return all distinct solutions to the n-queens puzzle.

Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.

Example:
#+BEGIN_EXAMPLE
Input: 4
Output: [
 [".Q..",  // Solution 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // Solution 2
  "Q...",
  "...Q",
  ".Q.."]
]
#+END_EXAMPLE

Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above.

* 053 Maximum Subarray :DivideAndConquer:Array:DP:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/maximum-subarray/description/][leetcode]]
:END:
** Problem
Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.

Example 1:
#+BEGIN_EXAMPLE
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: nums = [1]
Output: 1
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE
Input: nums = [0]
Output: 0
#+END_EXAMPLE

Example 4:
#+BEGIN_EXAMPLE
Input: nums = [-1]
Output: -1
#+END_EXAMPLE

Example 5:
#+BEGIN_EXAMPLE
Input: nums = [-2147483647]
Output: -2147483647
#+END_EXAMPLE

*Constraints:*
- 1 <= nums.length <= 2 * 104
- -231 <= nums[i] <= 231 - 1
* 062 Unique Paths :DP:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/unique-paths/description/][leetcode]]
:END:
** Problem
A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).
[[*Problem][Problem]]

How many possible unique paths are there?

*Example 1:*
#+BEGIN_EXAMPLE
Input: m = 3, n = 7
Output: 28
#+END_EXAMPLE

*Example 2:*
#+BEGIN_EXAMPLE
Input: m = 3, n = 2
Output: 3
Explanation:
From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Down -> Down
2. Down -> Down -> Right
3. Down -> Right -> Down
#+END_EXAMPLE


*Example 3:*
#+BEGIN_EXAMPLE
Input: m = 7, n = 3
Output: 28
#+END_EXAMPLE


*Example 4:*
#+BEGIN_EXAMPLE
Input: m = 3, n = 3
Output: 6
#+END_EXAMPLE

* 064 Minimum Path Sum :DP:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/minimum-path-sum/description/][leetcode]]
:END:
** Problem
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.

Example:
#+BEGIN_EXAMPLE
Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1→3→1→1→1 minimizes the sum.
#+END_EXAMPLE
* 069 Sqrt(x) :Math:BinarySearch:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/sqrtx/description/][leetcode]]
:END:
** Problem
Implement int sqrt(int x).

Compute and return the square root of x, where x is guaranteed to be a non-negative integer.

Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.

Example 1:
#+BEGIN_EXAMPLE
Input: 4
Output: 2
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: 8
Output: 2
Explanation: The square root of 8 is 2.82842..., and since
             the decimal part is truncated, 2 is returned.
#+END_EXAMPLE

* 070 Climbing Stairs :DP:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/climbing-stairs/description/][leetcode]]
:END:
** Problem
You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

*Example 1:*
#+BEGIN_EXAMPLE
Input: 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
#+END_EXAMPLE

*Example 2:*
#+BEGIN_EXAMPLE
Input: 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
#+END_EXAMPLE

*Constraints*:

1 <= n <= 45
** Solution
Source code in [[file:070_Climbing_Stairs/Java/Solution.java::class Solution{][Java]].
* 075 Sort Colors :Array:TwoPointers:Sort:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/sort-colors/description/][leetcode]]
:END:
** Problem
Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.

Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

Follow up:

Could you solve this problem without using the library's sort function?
Could you come up with a one-pass algorithm using only O(1) constant space?


Example 1:
#+BEGIN_EXAMPLE
Input: nums = [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: nums = [2,0,1]
Output: [0,1,2]
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE
Input: nums = [0]
Output: [0]
#+END_EXAMPLE

Example 4:
#+BEGIN_EXAMPLE
Input: nums = [1]
Output: [1]
#+END_EXAMPLE

*Constraints:*
#+BEGIN_QUOTE
n == nums.length
1 <= n <= 300
nums[i] is 0, 1, or 2.
#+END_QUOTE
* 077 Combinations :Backtracking:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/combinations/description/][leetcode]]
:END:
** Problem
Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.

You may return the answer in any order.



Example 1:

Input: n = 4, k = 2
Output:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
Example 2:

Input: n = 1, k = 1
Output: [[1]]


Constraints:

1 <= n <= 20
1 <= k <= n
* 078 Subsets
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/subsets/description/][leetcode]]
:END:
** Problem
Given a set of distinct integers, nums, return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

Example:
#+BEGIN_EXAMPLE
Input: nums = [1,2,3]
Output:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
#+END_EXAMPLE

* 079 Word Search :Backtracking:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/word-search/description/][leetcode]]
:END:
** Problem
Given a 2D board and a word, find if the word exists in the grid.

The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.

Example:
#+BEGIN_EXAMPLE
board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

Given word = "ABCCED", return true.
Given word = "SEE", return true.
Given word = "ABCB", return false.
#+END_EXAMPLE

Constraints:
- board and word consists only of lowercase and uppercase English letters.
- 1 <= board.length <= 200
- 1 <= board[i].length <= 200
- 1 <= word.length <= 10^3
* 088 Merge Sorted Array :TwoPointers:Array:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/merge-sorted-array/][leetcode]]
:END:
** Problem
Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.

*Note:*
- The number of elements initialized in nums1 and nums2 are m and n respectively.
- You may assume that nums1 has enough space (size that is equal to m + n) to hold additional elements from nums2.

*Example:*
#+BEGIN_EXAMPLE
Input:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

Output: [1,2,2,3,5,6]
#+END_EXAMPLE

Constraints:
#+BEGIN_QUOTE
-10^9 <= nums1[i], nums2[i] <= 10^9
nums1.length == m + n
nums2.length == n
#+END_QUOTE
* 090 Subsets II :Backtracking:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/subsets-ii/description/][leetcode]]
:END:
** Problem
Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

Example:
#+BEGIN_EXAMPLE
Input: [1,2,2]
Output:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
#+END_EXAMPLE

* 091 Decode Ways :String:DP:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/decode-ways/description/][leetcode]]
:END:
** Problem
A message containing letters from A-Z is being encoded to numbers using the following mapping:
#+BEGIN_QUOTE
'A' -> 1
'B' -> 2
...
'Z' -> 26
#+END_QUOTE

Given a non-empty string containing only digits, determine the total number of ways to decode it.

Example 1:
#+BEGIN_EXAMPLE
Input: "12"
Output: 2
Explanation: It could be decoded as "AB" (1 2) or "L" (12).
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: "226"
Output: 3
Explanation: It could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).
#+END_EXAMPLE
* 093 Restore IP Addresses :Backtracking:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/restore-ip-addresses/description/][leetcode]]
:END:
** Problem
Given a string s containing only digits, return all possible valid IP addresses that can be obtained from s. You can return them in any order.

A valid IP address consists of exactly four integers, each integer is between 0 and 255, separated by single dots and cannot have leading zeros. For example, "0.1.2.201" and "192.168.1.1" are valid IP addresses and "0.011.255.245", "192.168.1.312" and "192.168@1.1" are invalid IP addresses.


Example 1:
#+BEGIN_EXAMPLE
Input: s = "25525511135"
Output: ["255.255.11.135","255.255.111.35"]
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: s = "0000"
Output: ["0.0.0.0"]
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE
Input: s = "1111"
Output: ["1.1.1.1"]
#+END_EXAMPLE

Example 4:
#+BEGIN_EXAMPLE
Input: s = "010010"
Output: ["0.10.0.10","0.100.1.0"]
#+END_EXAMPLE

Example 5:
#+BEGIN_EXAMPLE
Input: s = "101023"
Output: ["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]

#+END_EXAMPLE



*Constraints:*
- 0 <= s.length <= 3000
- s consists of digits only.
* 095 Unique Binary Search Trees II :DP:Tree:DivideAndConquer:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/un
ique-binary-search-trees-ii/description/][leetcode]]
:END:
** Problem
Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1 ... n.

Example:
#+BEGIN_EXAMPLE
Input: 3
Output:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
#+END_EXAMPLE

*Explanation:*
The above output corresponds to the 5 unique BST's shown below:
#+BEGIN_QUOTE
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
#+END_QUOTE
* 101 Symmetric Tree :Tree:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/symmetric-tree/][leetcode]]
:END:
** Problem
Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).

For example, this binary tree [1,2,2,3,4,4,3] is symmetric:

    1
   / \
  2   2
 / \ / \
3  4 4  3


But the following [1,2,2,null,3,null,3] is not:

    1
   / \
  2   2
   \   \
   3    3


Follow up: Solve it both recursively and iteratively.
** Solution
Solution in [[file:101_Symmetric_Tree/Java/Solution.java::/**][Java]].
* 104 Maximum Depth of Binary Tree :Tree:DFS:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/maximum-depth-of-binary-tree/][leetcode]]
:END:
** Problem
Given a binary tree, find its maximum depth.

The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

Note: A leaf is a node with no children.

Example:
#+BEGIN_EXAMPLE
Given binary tree [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
return its depth = 3.
#+END_EXAMPLE
* 110 Balanced Binary Tree :Tree:DFS:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/balanced-binary-tree/][leetcode]]
:END:
** Problem
Given a binary tree, determine if it is height-balanced.

For this problem, a height-balanced binary tree is defined as:

a binary tree in which the left and right subtrees of every node differ in height by no more than 1.

Example 1:
#+BEGIN_EXAMPLE
Input: root = [3,9,20,null,null,15,7]
Output: true
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: root = [1,2,2,3,3,null,null,4,4]
Output: false
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE
Input: root = []
Output: true
#+END_EXAMPLE

Constraints:
- The number of nodes in the tree is in the range [0, 5000].
- -10^4 <= Node.val <= 10^4
* 111 Minimum Depth of Binary Tree :Tree:DFS:BFS:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/minimum-depth-of-binary-tree/][leetcode]]
:END:
** Problem
Given a binary tree, find its minimum depth.

The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.

Note: A leaf is a node with no children.

Example 1:
#+BEGIN_EXAMPLE
Input: root = [3,9,20,null,null,15,7]
Output: 2
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: root = [2,null,3,null,4,null,5,null,6]
Output: 5
#+END_EXAMPLE

*Constraints:*
- The number of nodes in the tree is in the range [0, 105].
- -1000 <= Node.val <= 1000

** Solution
Solution in [[file:111_Minimum_Depth_of_Binary_Tree/Java/Solution.java::/**][Java]].
* 112 Path Sum :Tree:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/path-sum/description/][leetcode]]
:END:
** Problem
Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.

Note: A leaf is a node with no children.

Example:
#+BEGIN_EXAMPLE
Given the below binary tree and sum = 22,

      5
     / \
    4   8
   /   / \
  11  13  4
 /  \      \
7    2      1
return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.
#+END_EXAMPLE

* 121 Best Time to Buy and Sell Stock
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/][leetcode]]
:END:
** Problem
Say you have an array for which the ith element is the price of a given stock on day i.

If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.

Note that you cannot sell a stock before you buy one.

Example 1:
#+BEGIN_EXAMPLE
Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
#+END_EXAMPLE
* 122 Best Time to Buy and Sell Stock II
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/][leetcode]]
:END:
** Problem
Say you have an array prices for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).

Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).

Example 1:
#+BEGIN_EXAMPLE
Input: [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
             engaging multiple transactions at the same time. You must sell before buying again.
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE
Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
#+END_EXAMPLE

*Constraints:*
- 1 <= prices.length <= 3 * 10 ^ 4
- 0 <= prices[i] <= 10 ^ 4
* 127 Word Ladder
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/word-ladder/description/][leetcode]]
:END:
** Problem
Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:
1. Only one letter can be changed at a time.
2. Each transformed word must exist in the word list.

*Note:*
- Return 0 if there is no such transformation sequence.
- All words have the same length.
- All words contain only lowercase alphabetic characters.
- You may assume no duplicates in the word list.
- You may assume beginWord and endWord are non-empty and are not the same.

Example 1:
#+BEGIN_EXAMPLE
Input:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

Output: 5

Explanation: As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",
return its length 5.
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]

Output: 0

Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.

#+END_EXAMPLE
* 130 Surrounded Regions :DFS:BFS:UnionFind:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/surrounded-regions/description/][leetcode]]
:END:
** Problem
Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.

A region is captured by flipping all 'O's into 'X's in that surrounded region.

*Example:*
#+BEGIN_EXAMPLE
X X X X
X O O X
X X O X
X O X X
After running your function, the board should be:

X X X X
X X X X
X X X X
X O X X
#+END_EXAMPLE

*Explanation:*

Surrounded regions shouldn’t be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.
* 131 Palindrome Partitioning :Backtracking:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/palindrome-partitioning/description/][leetcode]]
:END:
Given a string s, partition s such that every substring of the partition is a palindrome.

Return all possible palindrome partitioning of s.

Example:
#+BEGIN_EXAMPLE
Input: "aab"
Output:
[
  ["aa","b"],
  ["a","a","b"]
]
#+END_EXAMPLE
* 139 Word Break :DP:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/word-break/description/][leetcode]]
:END:
** Problem
Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.

*Note:*
- The same word in the dictionary may be reused multiple times in the segmentation.
- You may assume the dictionary does not contain duplicate words.

Example 1:
#+BEGIN_EXAMPLE
Input: s = "leetcode", wordDict = ["leet", "code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: s = "applepenapple", wordDict = ["apple", "pen"]
Output: true
Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
             Note that you are allowed to reuse a dictionary word.
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE
Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
Output: false
#+END_EXAMPLE

* 141 Linked List Cycle :TwoPointers:LinkedList:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/linked-list-cycle/][leetcode]]
:END:
** Problem
Given head, the head of a linked list, determine if the linked list has a cycle in it.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.

Return true if there is a cycle in the linked list. Otherwise, return false.

Follow up:

Can you solve it using O(1) (i.e. constant) memory?

Example 1:

[[download:141_Linked_List_Cycle/_20200922_083807circularlinkedlist.png]]

#+BEGIN_EXAMPLE
Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).
#+END_EXAMPLE

Example 2:

[[download:141_Linked_List_Cycle/_20200922_083938circularlinkedlist_test2.png]]

#+BEGIN_EXAMPLE
Input: head = [1,2], pos = 0
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.
#+END_EXAMPLE

Example 3:

[[download:141_Linked_List_Cycle/_20200922_083918circularlinkedlist_test3.png]]

#+BEGIN_EXAMPLE
Input: head = [1], pos = -1
Output: false
Explanation: There is no cycle in the linked list.
#+END_EXAMPLE

* 143 Reorder List :LinkedList:
:PROPERTIES:
:Difficulty: Medium
:END:
:LOGBOOK:
CLOCK: [2020-07-04 Sat 15:24]--[2020-07-04 Sat 17:46] =>  2:22
CLOCK: [2020-07-04 Sat 10:38]--[2020-07-04 Sat 11:50] =>  1:12
:END:
** Problem
Given a singly linked list L: L0→L1→…→Ln-1→Ln,
reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…

You may not modify the values in the list's nodes, only nodes itself may be
changed.

** Example
#+BEGIN_EXAMPLE
Given 1->2->3->4, reorder it to 1->4->2->3.
#+END_EXAMPLE

#+BEGIN_EXAMPLE
Given 1->2->3->4->5, reorder it to 1->5->2->4->3.
#+END_EXAMPLE

** Solution
*** First Try
We first get a reversed linked list, and then we travel the two linked list in
the same time until the value meet (The middle value).
The time complexity will be 2n or O(n), space complexity will be n or O(n).

Question: how we know we should stop, or how shall we know it's middle value.
Answer: It's singly linked list, so we can simple compare with the value, value
from the natual linked list should always left than or equal than the reversed
order one, and at one point, they will meet with the same value, then should
stop the loop.

currL -> L0;
nextL -> L1;
currRL > Ln;

L0->Ln;
currL -> L1;
nextL -> Ln-1;
currRL -> L2;

Failed, reason is the assumption which the linked list is ordered is incorrect,
in this case, we can only do the count for the reverse part. That's quite ugly.
*** Second Try
For linked list, we have so called "fast-slow-pointer", which means we set two
points to do the travesal of the singly linked list, slow pointer goes
one step in one round, while fast pointer goes two steps in one round, so when
fast pointer reach the end, we could imagine that the slow pointer exactly
stopped in the middle of the list.

Second step is, start at the middle position (slow->next), we start to reverse
the list, by the end of this step, we have two list, one is the natual list
pointd by head, the other is reversed from tail pointed by tail.

Last step is to compose the new list with the two lists, it's pretty easy step
to go.
* 144 Binary Tree Preorder Traversal :Tree:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/binary-tree-preorder-traversal/][leetcode]]
:END:
** Problem
Given the root of a binary tree, return the preorder traversal of its nodes' values.

Example 1:
#+BEGIN_EXAMPLE
Input: root = [1,null,2,3]
Output: [1,2,3]
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: root = []
Output: []
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE
Input: root = [1]
Output: [1]
#+END_EXAMPLE

Example 4:
#+BEGIN_EXAMPLE
Input: root = [1,2]
Output: [1,2]
#+END_EXAMPLE

Example 5:
#+BEGIN_EXAMPLE
Input: root = [1,null,2]
Output: [1,2]
#+END_EXAMPLE

*Constraints:*
- The number of nodes in the tree is in the range [0, 100].
- -100 <= Node.val <= 100

*Follow up:*

Recursive solution is trivial, could you do it iteratively?
* 145 Binary Tree Postorder Traversal :Tree:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/binary-tree-postorder-traversal/][leetcode]]
:END:
** Problem
Given the root of a binary tree, return the postorder traversal of its nodes' values.

Example 1:
#+BEGIN_EXAMPLE
Input: root = [1,null,2,3]
Output: [3,2,1]
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: root = []
Output: []
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE
Input: root = [1]
Output: [1]
#+END_EXAMPLE

Example 4:
#+BEGIN_EXAMPLE
Input: root = [1,2]
Output: [2,1]
#+END_EXAMPLE

Example 5:
#+BEGIN_EXAMPLE
Input: root = [1,null,2]
Output: [2,1]
#+END_EXAMPLE

*Constraints:*
- The number of the nodes in the tree is in the range [0, 100].
- -100 <= Node.val <= 100


*Follow up:*
Recursive solution is trivial, could you do it iteratively?
* 153 Find Minimum in Rotated Sorted Array :BinarySearch:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/][leetcode]]
:END:
** Problem
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).

Find the minimum element.

You may assume no duplicate exists in the array.

Example 1:
#+BEGIN_EXAMPLE
Input: [3,4,5,1,2]
Output: 1
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: [4,5,6,7,0,1,2]
Output: 0
#+END_EXAMPLE

* 167 Two Sum II :Array:TwoPointers:
:PROPERTIES:
:Difficulty: Easy
:END:
** Problem
Given an array of integers that is already sorted in ascending order, find two
numbers such that they add up to a specific target number.

The function twoSum should return indices of the two numbers such that they add
up to the target, where index1 must be less than index2.

*Note*:
- Your returned answers (both index1 and index2) are not zero-based.
- You may assume that each input would have exactly one solution and you may not
  use the same element twice.

*Example 1*
#+BEGIN_EXAMPLE
Input: numbers = [2,7,11,15], target = 9

Output: [1,2]

Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.
#+END_EXAMPLE
** Solution
*** Binary Search
We could of course still use the hasmap solution, which has both time and space
complexity of ~O(n)~. However, since the array is sorted, with the keyword
~sorted~, binary search jump into my mind. In this case, time complexity would
be O(n*log(n)), which is worse, but there's no extra space needed.

Pseudo Code:
#+BEGIN_EXAMPLE
1. Loop the array =numbers= with index =i=:
   - let =y=target-numbers[i]=
   - Do binary search of =y= on =numbers= (low = i)
   - If found, return [i+1,j+1]
#+END_EXAMPLE
*** Two Pointers
Apparently, ~O(n*logn)~ seems is not a good solution. We then can think
something of ~quick sort~, which uses two points, we can adapt the same idea
with keeping no extra space used but lowered the time complexity to ~O(n)~.

Pseudo Code:
#+BEGIN_EXAMPLE
1. Put the =lo= pointer to 0 and =hi= pointer to =lengh-1=
2. Set =y=target-numbers[lo]=, compare and move =hi= until =y>=numbers[hi]=
3. If =y!=numbers[hi]=, move lo forward, and repeat step 2.
#+END_EXAMPLE
* 168 Excel Sheet Column Title :Math:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/excel-sheet-column-title/][leetcode]]
:END:
** Problem
Given a positive integer, return its corresponding column title as appear in an Excel sheet.

For example:

    1 -> A
    2 -> B
    3 -> C
    ...
    26 -> Z
    27 -> AA
    28 -> AB
    ...
Example 1:
#+BEGIN_EXAMPLE
Input: 1
Output: "A"
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: 28
Output: "AB"
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE
Input: 701
Output: "ZY"
#+END_EXAMPLE
* 172 Factorial Trailing Zeroes :Math:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/factorial-trailing-zeroes/description/][leetcode]]
:END:
** Problem
Given an integer n, return the number of trailing zeroes in n!.

Follow up: Could you write a solution that works in logarithmic time complexity?

Example 1:
#+BEGIN_EXAMPLE
Input: n = 3
Output: 0
Explanation: 3! = 6, no trailing zero.
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: n = 5
Output: 1
Explanation: 5! = 120, one trailing zero.
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE
Input: n = 0
Output: 0
#+END_EXAMPLE

Constraints:
- 1 <= n <= 104

* 198 House Robber :DP:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/house-robber/submissions/][leetcode]]
:END:
** Problem
You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.



*Example 1:*
#+BEGIN_EXAMPLE
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.
#+END_EXAMPLE

*Example 2:*
#+BEGIN_EXAMPLE
Input: nums = [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
             Total amount you can rob = 2 + 9 + 1 = 12.

#+END_EXAMPLE

*Constraints:*

0 <= nums.length <= 100
0 <= nums[i] <= 400
** Solution
* 200 Number of Islands :DFS:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/number-of-islands/description/][leetcode]]
:END:
** Problem
Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

Example 1:
#+BEGIN_EXAMPLE
Input: grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
Output: 1
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
Output: 3
#+END_EXAMPLE
* 204 Count Primes :Math:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/count-primes/description/][leetcode]]
:END:
** Problem
Count the number of prime numbers less than a non-negative number, n.

Example 1:
#+BEGIN_EXAMPLE
Input: n = 10
Output: 4
Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: n = 0
Output: 0
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE
Input: n = 1
Output: 0
#+END_EXAMPLE

*Constraints:*
- 0 <= n <= 5 * 10^6
* 213 House Robber II :DP:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/house-robber-ii/description/][leetcode]]
:END:
** Problem
You are a professional robber planning to rob houses along a street. Each house
has a certain amount of money stashed. All houses at this place are arranged in
a circle. That means the first house is the neighbor of the last one. Meanwhile,
adjacent houses have security system connected and it will automatically contact
the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each
house, determine the maximum amount of money you can rob tonight without
alerting the police.

*Example 1:*
#+BEGIN_EXAMPLE
Input: [2,3,2]
Output: 3
Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),
             because they are adjacent houses.
#+END_EXAMPLE

*Example 2:*
#+BEGIN_EXAMPLE
Input: [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.
#+END_EXAMPLE

** Solution
Similar to Problem 198 House Robber, need additional consideration if the first
house is robbed or not.
* 215 Kth Largest Element in an Array :Heap:DivideAndConquer:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/kth-largest-element-in-an-array/description/][leetcode]]
:END:
** Problem
Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.

Example 1:
#+BEGIN_EXAMPLE
Input: [3,2,1,5,6,4] and k = 2
Output: 5
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: [3,2,3,1,2,4,5,5,6] and k = 4
Output: 4
#+END_EXAMPLE

*Note:*
You may assume k is always valid, 1 ≤ k ≤ array's length.
* 216 Combination Sum III :Backtracking:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/combination-sum-iii/description/][leetcode]]
:END:
** Problem
Find all valid combinations of k numbers that sum up to n such that the following conditions are true:

Only numbers 1 through 9 are used.
Each number is used at most once.
Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.


Example 1:
#+BEGIN_EXAMPLE
Input: k = 3, n = 7
Output: [[1,2,4]]
Explanation:
1 + 2 + 4 = 7
There are no other valid combinations.
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: k = 3, n = 9
Output: [[1,2,6],[1,3,5],[2,3,4]]
Explanation:
1 + 2 + 6 = 9
1 + 3 + 5 = 9
2 + 3 + 4 = 9
There are no other valid combinations.
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE
Input: k = 4, n = 4
Output: []
Explanation: There are no valid combinations. [1,2,1] is not valid because 1 is used twice.
#+END_EXAMPLE

Example 4:
#+BEGIN_EXAMPLE
Input: k = 3, n = 2
Output: []
Explanation: There are no valid combinations.
#+END_EXAMPLE

Example 5:
#+BEGIN_EXAMPLE
Input: k = 9, n = 45
Output: [[1,2,3,4,5,6,7,8,9]]
Explanation:
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45
​​​​​​​There are no other valid combinations.
#+END_EXAMPLE

*Constraints:*
- 2 <= k <= 9
- 1 <= n <= 60
* 226 Invert Binary Tree :Tree:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/invert-binary-tree/][leetcode]]
:END:
** Problem
Invert a binary tree.

Example:
#+BEGIN_EXAMPLE
Input:

     4
   /   \
  2     7
 / \   / \
1   3 6   9
Output:

     4
   /   \
  7     2
 / \   / \
9   6 3   1
#+END_EXAMPLE

Trivia:
This problem was inspired by this original tweet by Max Howell:

Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.
** Solution

* 241 Different Ways to Add Parenthese :DivideAndConquer:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/different-ways-to-add-parentheses/description/][leetcode]]
:END:
** Problem
Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *.

Example 1:
#+BEGIN_EXAMPLE
Input: "2-1-1"
Output: [0, 2]
Explanation:
((2-1)-1) = 0
(2-(1-1)) = 2
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: "2*3-4*5"
Output: [-34, -14, -10, -10, 10]
Explanation:
(2*(3-(4*5))) = -34
((2*3)-(4*5)) = -14
((2*(3-4))*5) = -10
(2*((3-4)*5)) = -10
(((2*3)-4)*5) = 10
#+END_EXAMPLE
* 257 Binary Tree Path :DFS:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/binary-tree-paths/description/][leetcode]]
:END:
** Problem
Given a binary tree, return all root-to-leaf paths.

Note: A leaf is a node with no children.

Example:
#+BEGIN_EXAMPLE
Input:

   1
 /   \
2     3
 \
  5

Output: ["1->2->5", "1->3"]

Explanation: All root-to-leaf paths are: 1->2->5, 1->3
#+END_EXAMPLE

* 278 First Bad Version :BinarySearch:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/first-bad-version/description/][leetcode]]
:END:
** Problem
You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.

You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.

Example:
#+BEGIN_EXAMPLE
Given n = 5, and version = 4 is the first bad version.

call isBadVersion(3) -> false
call isBadVersion(5) -> true
call isBadVersion(4) -> true

Then 4 is the first bad version.
#+END_EXAMPLE

* 279 Perfect Squares :Math:DP:BFS:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/perfect-squares/description/][leetcode]]
:END:
** Problem
Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.

Example 1:
#+BEGIN_EXAMPLE
Input: n = 12
Output: 3
Explanation: 12 = 4 + 4 + 4.
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: n = 13
Output: 2
Explanation: 13 = 4 + 9.
#+END_EXAMPLE
* 300 Longest Increasing Subsequence :BinarySearch:DP:
:PROPERTIES:
:Link:     [[https://leetcode.com/problems/longest-increasing-subsequence/description/][leetcode]]
:Difficulty: Medium
:END:
** Problem
Given an unsorted array of integers, find the length of longest increasing subsequence.

Example:
#+BEGIN_EXAMPLE
Input: [10,9,2,5,3,7,101,18]
Output: 4
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.
#+END_EXAMPLE

*Note:*
- There may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity.
- Follow up: Could you improve it to O(n log n) time complexity?

* 303 Range Sum Query - Immutable :DP:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/range-sum-query-immutable/description/][leetcode]]
:END:
** Problem
Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.

Example:
#+BEGIN_EXAMPLE
Given nums = [-2, 0, 3, -5, 2, -1]

sumRange(0, 2) -> 1
sumRange(2, 5) -> -1
sumRange(0, 5) -> -3
#+END_EXAMPLE

*Constraints:*
- You may assume that the array does not change.
- There are many calls to sumRange function.
- 0 <= nums.length <= 10^4
- -10^5 <= nums[i] <= 10^5
- 0 <= i <= j < nums.length
* 309 Best Time to Buy and Sell Stock with Cooldown :DP:
:PROPERTIES:
:Link:     [[https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/][leetcode]]
:Difficulty: Medium
:END:
** Problem
Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:

You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).
After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)

Example:
#+BEGIN_EXAMPLE
Input: [1,2,3,0,2]
Output: 3
Explanation: transactions = [buy, sell, cooldown, buy, sell]
#+END_EXAMPLE

* 322 Coin Change :DP:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/coin-change/description/][leetcode]]
:END:
** Problem
You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.

You may assume that you have an infinite number of each kind of coin.

Example 1:
#+BEGIN_EXAMPLE
Input: coins = [1,2,5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: coins = [2], amount = 3
Output: -1
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE
Input: coins = [1], amount = 0
Output: 0
#+END_EXAMPLE

Example 4:
#+BEGIN_EXAMPLE
Input: coins = [1], amount = 1
Output: 1
#+END_EXAMPLE

Example 5:
#+BEGIN_EXAMPLE
Input: coins = [1], amount = 2
Output: 2
 #+END_EXAMPLE

*Constraints:*

- 1 <= coins.length <= 12
- 1 <= coins[i] <= 2^31 - 1
- 0 <= amount <= 10^4
* 328 Odd Even Linked List :LinkedList:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/odd-even-linked-list/][leetcode]]
:END:
** Problem
Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.

You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.

Example 1:
#+BEGIN_EXAMPLE
Input: 1->2->3->4->5->NULL
Output: 1->3->5->2->4->NULL
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: 2->1->3->5->6->4->7->NULL
Output: 2->3->6->7->1->5->4->NULL
#+END_EXAMPLE

*Constraints:*
- The relative order inside both the even and odd groups should remain as it was in the input.
- The first node is considered odd, the second node even and so on ...
- The length of the linked list is between [0, 10^4].

* 337 House Robber III :Tree:DFS:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/house-robber-ii/description/][leetcode]]
:END:
** Problem
The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the "root." Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that "all houses in this place forms a binary tree". It will automatically contact the police if two directly-linked houses were broken into on the same night.

Determine the maximum amount of money the thief can rob tonight without alerting the police.

Example 1:
#+BEGIN_EXAMPLE
Input: [3,2,3,null,3,null,1]

     3
    / \
   2   3
    \   \
     3   1

Output: 7
Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: [3,4,5,1,3,null,1]

     3
    / \
   4   5
  / \   \
 1   3   1

Output: 9
Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9.
#+END_EXAMPLE
** Solution
Solution in [[file:377_House_Robber_III/Java/Solution.java::class Solution {][Java]].

* 343 Integer Break :DP:Math:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/integer-break/description/][leetcode]]
:END:
** Problem
Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of  those integers. Return the maximum product you can get.

Example 1:
#+BEGIN_EXAMPLE
Input: 2
Output: 1
Explanation: 2 = 1 + 1, 1 × 1 = 1.
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: 10
Output: 36
Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36.
Note: You may assume that n is not less than 2 and not larger than 58.
#+END_EXAMPLE
* 345 Reverse Vowels of a String :TwoPointers:String:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/reverse-vowels-of-a-string/description/][leetcode]]
:END:
** Problem
Write a function that takes a string as input and reverse only the vowels of a string.

Example 1:
#+BEGIN_EXAMPLE
Input: "hello"
Output: "holle"
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: "leetcode"
Output: "leotcede"
#+END_EXAMPLE

*Note:*
The vowels does not include the letter "y".
* 347 Top K Frequent Elements :HashTable:Heap:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/top-k-frequent-elements/description/][leetcode]]
:END:
** Problem
Given a non-empty array of integers, return the k most frequent elements.

Example 1:
#+BEGIN_EXAMPLE
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: nums = [1], k = 1
Output: [1]
#+END_EXAMPLE

*Note:*

- You may assume k is always valid, 1 ≤ k ≤ number of unique elements.
- Your algorithm's time complexity must be better than O(n log n), where n is the array's size.
- It's guaranteed that the answer is unique, in other words the set of the top k frequent elements is unique.
- You can return the answer in any order.
* 376 Wiggle Subsequence :DP:Greedy:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/wiggle-subsequence/description/][leetcode]]
:END:
** Problem
A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence.

For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero.

Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.

Example 1:
#+BEGIN_EXAMPLE
Input: [1,7,4,9,2,5]
Output: 6
Explanation: The entire sequence is a wiggle sequence.
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: [1,17,5,10,13,15,10,5,16,8]
Output: 7
Explanation: There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE
Input: [1,2,3,4,5,6,7,8,9]
Output: 2
Follow up:
Can you do it in O(n) time?
#+END_EXAMPLE

** Solution
[[file:376_Wiggle_Subsequence/Java/Solution.java][Java Solution]]
* 377 Combination Sum IV :DP:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/combination-sum-iv/description/][leetcode]]
:END:
** Problem
Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.

Example:
#+BEGIN_EXAMPLE
nums = [1, 2, 3]
target = 4

The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

Note that different sequences are counted as different combinations.

Therefore the output is 7.
#+END_EXAMPLE

*Follow up:*
What if negative numbers are allowed in the given array?
How does it change the problem?
What limitation we need to add to the question to allow negative numbers?

* 392 Is Subsequence :BinarySearch:DP:Greedy:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/is-subsequence/description/][leetcode]]
:END:
** Problem
Given a string s and a string t, check if s is subsequence of t.

A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ace" is a subsequence of "abcde" while "aec" is not).

Follow up:
If there are lots of incoming S, say S1, S2, ... , Sk where k >= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?

Credits:
Special thanks to @pbrother for adding this problem and creating all test cases.

Example 1:
#+BEGIN_EXAMPLE
Input: s = "abc", t = "ahbgdc"
Output: true
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: s = "axc", t = "ahbgdc"
Output: false
#+END_EXAMPLE

*Constraints:*
- 0 <= s.length <= 100
- 0 <= t.length <= 10^4
- Both strings consists only of lowercase characters.
* 404 Sum of Left Leaves :Tree:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/sum-of-left-leaves/][leetcode]]
:END:
** Problem
Find the sum of all left leaves in a given binary tree.

Example:
#+BEGIN_EXAMPLE
    3
   / \
  9  20
    /  \
   15   7

There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.
#+END_EXAMPLE
** Solution
Solution in [[file:404_Sum_of_Left_Leaves/Java/Solution.java::class Solution {][Java]].

* 405 Convert a Number to Hexadecimal :Math:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/convert-a-number-to-hexadecimal/description/][leetcode]]
:END:
** Problem
Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, two’s complement method is used.

Note:

All letters in hexadecimal (a-f) must be in lowercase.
The hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character '0'; otherwise, the first character in the hexadecimal string will not be the zero character.
The given number is guaranteed to fit within the range of a 32-bit signed integer.
You must not use any method provided by the library which converts/formats the number to hex directly.

Example 1:
#+BEGIN_EXAMPLE
Input:
26

Output:
"1a"
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input:
-1

Output:
"ffffffff"
#+END_EXAMPLE

* 406 Queue Reconstruction by Height :Greedy:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/queue-reconstruction-by-height/description/][leetcode]]
:END:
** Problem
Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue.

*Note:*
The number of people is less than 1,100.


Example
#+BEGIN_EXAMPLE
Input:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

Output:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
#+END_EXAMPLE

* 413 Arithmetic Slices :DP:Math:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/arithmetic-slices/description/][leetcode]]
:END:
** Problem
A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.

For example, these are arithmetic sequences:

1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9
The following sequence is not arithmetic.

1, 1, 2, 5, 7

A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 <= P < Q < N.

A slice (P, Q) of the array A is called arithmetic if the sequence:
A[P], A[P + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 < Q.

The function should return the number of arithmetic slices in the array A.


*Example:*
#+BEGIN_EXAMPLE
A = [1, 2, 3, 4]

return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.
#+END_EXAMPLE
* 416 Partition Equal Subset Sum :DP:
:PROPERTIES:
:Link:     [[https://leetcode.com/problems/partition-equal-subset-sum/submissions/][leetcode]]
:Difficulty: Medium
:END:
** Problem
Given a non-empty array nums containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.

Example 1:
#+BEGIN_EXAMPLE
Input: nums = [1,5,11,5]
Output: true
Explanation: The array can be partitioned as [1, 5, 5] and [11].
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: nums = [1,2,3,5]
Output: false
Explanation: The array cannot be partitioned into equal sum subsets.
 #+END_EXAMPLE

*Constraints:*
- 1 <= nums.length <= 200
- 1 <= nums[i] <= 100

* 417 Pacific Atlantic Water Flow :DFS:BFS:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/pacific-atlantic-water-flow/description/][leetcode]]
:END:
** Problem
Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the "Pacific ocean" touches the left and top edges of the matrix and the "Atlantic ocean" touches the right and bottom edges.

Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.

Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.

*Note:*
1. The order of returned grid coordinates does not matter.
2. Both m and n are less than 150.


Example:
#+BEGIN_EXAMPLE
Given the following 5x5 matrix:

  Pacific ~   ~   ~   ~   ~
       ~  1   2   2   3  (5) *
       ~  3   2   3  (4) (4) *
       ~  2   4  (5)  3   1  *
       ~ (6) (7)  1   4   5  *
       ~ (5)  1   1   2   4  *
          *   *   *   *   * Atlantic

Return:

[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).
#+END_EXAMPLE

* 435 Non-overlapping Intervals :Greedy:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/non-overlapping-intervals/description/][leetcode]]
:END:
** Problem
Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.

Example 1:
#+BEGIN_EXAMPLE
Input: [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: [1,3] can be removed and the rest of intervals are non-overlapping.
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: [[1,2],[1,2],[1,2]]
Output: 2
Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE
Input: [[1,2],[2,3]]
Output: 0
Explanation: You don't need to remove any of the intervals since they're already non-overlapping.
#+END_EXAMPLE

*Note:*
#+BEGIN_QUOTE
1. You may assume the interval's end point is always bigger than its start point.
2. Intervals like [1,2] and [2,3] have borders "touching" but they don't overlap each other.
#+END_QUOTE
* 437 Path Sum III :Tree:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/path-sum-iii/][leetcode]]
:END:
** Problem
ou are given a binary tree in which each node contains an integer value.

Find the number of paths that sum to a given value.

The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).

The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.

Example:
#+BEGIN_EXAMPLE
root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

Return 3. The paths that sum to 8 are:

1.  5 -> 3
2.  5 -> 2 -> 1
3. -3 -> 11
#+END_EXAMPLE

** Solution
Solution in [[file:437_Path_Sum_III/Java/Solution.java::}][Java]].

* 445 Add Two Numbers II :LinkedList:
:PROPERTIES:
:Difficulty: Medium
:END:
** Problem
You are given two non-empty linked lists representing two non-negative
integers. The most significant digit comes first and each of their nodes contain
a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Follow up:
What if you cannot modify the input lists? In other words, reversing the lists is not allowed.

*Example 1*
#+BEGIN_EXAMPLE
Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 8 -> 0 -> 7
#+END_EXAMPLE
** Solution
One option would be reverse the two linked list, then we can follow the same solution as in problem 002 Add Two numbers.
In this case, what we can do is the reverse of linked list. This is easy to do.

While the follow up says, we cannot reverse the list, so we need to figure other option. The similar function would be use a StackList.
* 451 Sort Characters By Frequency :HashTable:Heap:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/sort-characters-by-frequency/description/][leetcode]]
:END:
** Problem
Given a string, sort it in decreasing order based on the frequency of characters.

Example 1:
#+BEGIN_EXAMPLE
Input:
"tree"

Output:
"eert"

Explanation:
'e' appears twice while 'r' and 't' both appear once.
So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input:
"cccaaa"

Output:
"cccaaa"

Explanation:
Both 'c' and 'a' appear three times, so "aaaccc" is also a valid answer.
Note that "cacaca" is incorrect, as the same characters must be together.
Example 3:

Input:
"Aabb"

Output:
"bbAa"

Explanation:
"bbaA" is also a valid answer, but "Aabb" is incorrect.
Note that 'A' and 'a' are treated as two different characters.
#+END_EXAMPLE
* 452 Minimum Number of Arrows to Burst Balloons
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/][leetcode]]
:END:
** Problem
There are some spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter, and hence the x-coordinates of start and end of the diameter suffice. The start is always smaller than the end.

An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps traveling up infinitely.

Given an array points where points[i] = [xstart, xend], return the minimum number of arrows that must be shot to burst all balloons.



Example 1:
#+BEGIN_EXAMPLE
Input: points = [[10,16],[2,8],[1,6],[7,12]]
Output: 2
Explanation: One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: points = [[1,2],[3,4],[5,6],[7,8]]
Output: 4
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE
Input: points = [[1,2],[2,3],[3,4],[4,5]]
Output: 2
#+END_EXAMPLE

Example 4:
#+BEGIN_EXAMPLE
Input: points = [[1,2]]
Output: 1
#+END_EXAMPLE

Example 5:
#+BEGIN_EXAMPLE
Input: points = [[2,3],[2,3]]
Output: 1
#+END_EXAMPLE

*Constraints:*
- 0 <= points.length <= 10^4
- points.length == 2
- -2^31 <= x_start < x_end <= 2^31 - 1

* 455 Assign Cookies :Greedy:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/assign-cookies/][leetcode]]
:END:
** Problem
Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj >= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.

Note:
You may assume the greed factor is always positive.
You cannot assign more than one cookie to one child.

Example 1:
#+BEGIN_EXAMPLE
Input: [1,2,3], [1,1]

Output: 1

Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3.
And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.
You need to output 1.
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: [1,2], [1,2,3]

Output: 2

Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2.
You have 3 cookies and their sizes are big enough to gratify all of the children,
You need to output 2.
#+END_EXAMPLE
* 474 Ones and Zeros :DP:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/ones-and-zeroes/][leetcode]]
:END:
** Problem
You are given an array of binary strings strs and two integers m and n.

Return the size of the largest subset of strs such that there are at most m 0's and n 1's in the subset.

A set x is a subset of a set y if all elements of x are also elements of y.


Example 1:
#+BEGIN_EXAMPLE
Input: strs = ["10","0001","111001","1","0"], m = 5, n = 3
Output: 4
Explanation: The largest subset with at most 5 0's and 3 1's is {"10", "0001", "1", "0"}, so the answer is 4.
Other valid but smaller subsets include {"0001", "1"} and {"10", "1", "0"}.
{"111001"} is an invalid subset because it contains 4 1's, greater than the maximum of 3.
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: strs = ["10","0","1"], m = 1, n = 1
Output: 2
Explanation: The largest subset is {"0", "1"}, so the answer is 2.
#+END_EXAMPLE

*Constraints:*
- 1 <= strs.length <= 600
- 1 <= strs[i].length <= 100
- strs[i] consists only of digits '0' and '1'.
- 1 <= m, n <= 100
** Solution
[[*Solution][Solution.java]]
* 494 Target Sum :DP:DFS:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/target-sum/][leetcode]]
:END:
** Problem
You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.

Find out how many ways to assign symbols to make sum of integers equal to target S.

Example 1:
#+BEGIN_EXAMPLE
Input: nums is [1, 1, 1, 1, 1], S is 3.
Output: 5
Explanation:

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

There are 5 ways to assign symbols to make the sum of nums be target 3.
#+END_EXAMPLE

*Constraints:*

- The length of the given array is positive and will not exceed 20.
- The sum of elements in the given array will not exceed 1000.
- Your output answer is guaranteed to be fitted in a 32-bit integer.
* 504 Base 7 :Math:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/base-7/][leetcode]]
:END:
** Problem
Given an integer, return its base 7 string representation.

Example 1:
#+BEGIN_EXAMPLE
Input: 100
Output: "202"
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: -7
Output: "-10"
#+END_EXAMPLE

Note: The input will be in range of [-1e7, 1e7].
* 513 Find Bottom Left Tree Value :BFS:Tree:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/find-bottom-left-tree-value/][leetcode]]
:END:
** Problem
Given a binary tree, find the leftmost value in the last row of the tree.

Example 1:
#+BEGIN_EXAMPLE
Input:

    2
   / \
  1   3

Output:
1
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input:

        1
       / \
      2   3
     /   / \
    4   5   6
       /
      7

Output:
7
#+END_EXAMPLE

Note: You may assume the tree (i.e., the given root node) is not NULL.
* 514 Freedom Trial :DivideAndConquer:DP:DFS:
:PROPERTIES:
:Difficulty: Hard
:Link:     [[https://leetcode.com/problems/freedom-trail/][leetcode]]
:END:
** Problem
In the video game Fallout 4, the quest "Road to Freedom" requires players to reach a metal dial called the "Freedom Trail Ring", and use the dial to spell a specific keyword in order to open the door.

Given a string ring, which represents the code engraved on the outer ring and another string key, which represents the keyword needs to be spelled. You need to find the minimum number of steps in order to spell all the characters in the keyword.

Initially, the first character of the ring is aligned at 12:00 direction. You need to spell all the characters in the string key one by one by rotating the ring clockwise or anticlockwise to make each character of the string key aligned at 12:00 direction and then by pressing the center button.

At the stage of rotating the ring to spell the key character key[i]:

You can rotate the ring clockwise or anticlockwise one place, which counts as 1 step. The final purpose of the rotation is to align one of the string ring's characters at the 12:00 direction, where this character must equal to the character key[i].
If the character key[i] has been aligned at the 12:00 direction, you need to press the center button to spell, which also counts as 1 step. After the pressing, you could begin to spell the next character in the key (next stage), otherwise, you've finished all the spelling.

Example:
#+BEGIN_EXAMPLE
Input: ring = "godding", key = "gd"
Output: 4
Explanation:
For the first key character 'g', since it is already in place, we just need 1 step to spell this character.
For the second key character 'd', we need to rotate the ring "godding" anticlockwise by two steps to make it become "ddinggo".
Also, we need 1 more step for spelling.
So the final output is 4.
#+END_EXAMPLE

*Note:*
- Length of both ring and key will be in range 1 to 100.
- There are only lowercase letters in both strings and might be some duplcate characters in both strings.
- It's guaranteed that string key could always be spelled by rotating the string ring.
* 518 Coin Change 2 :DP:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/coin-change-2/description/][leetcode]]
:END:
** Problem
You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.

Example 1:
#+BEGIN_EXAMPLE
Input: amount = 5, coins = [1, 2, 5]
Output: 4
Explanation: there are four ways to make up the amount:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: amount = 3, coins = [2]
Output: 0
Explanation: the amount of 3 cannot be made up just with coins of 2.
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE
Input: amount = 10, coins = [10]
Output: 1
#+END_EXAMPLE

*Note:*

You can assume that
- 0 <= amount <= 5000
- 1 <= coin <= 5000
- the number of coins is less than 500
- the answer is guaranteed to fit into signed 32-bit integer
* 540 Single Element in a Sorted Array :BinarySearch:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/single-element-in-a-sorted-array/description/][leetcode]]
:END:
** Problem
You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once. Find this single element that appears only once.

Follow up: Your solution should run in O(log n) time and O(1) space.

Example 1:
#+BEGIN_EXAMPLE
Input: nums = [1,1,2,3,3,4,4,8,8]
Output: 2
#+END_EXAMPLE


Example 2:
#+BEGIN_EXAMPLE
Input: nums = [3,3,7,7,10,11,11]
Output: 10
#+END_EXAMPLE

*Constraints:*
- 1 <= nums.length <= 10^5
- 0 <= nums[i] <= 10^5

* 542 Longest Word in Dictionary Through Deleting :TwoPointers:Sort:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/description/][leetcode]]
:END:
** Problem
Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.

Example 1:
#+BEGIN_EXAMPLE
Input:
s = "abpcplea", d = ["ale","apple","monkey","plea"]

Output:
"apple"
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input:
s = "abpcplea", d = ["a","b","c"]

Output:
"a"
#+END_EXAMPLE

*Note:*

All the strings in the input will only contain lower-case letters.
The size of the dictionary won't exceed 1,000.
The length of all the strings in the input won't exceed 1,000.
* 543 Diameter of Binary Tree :Tree:
:PROPERTIES:
:Link:     [[https://leetcode.com/problems/diameter-of-binary-tree/description/][leetcode]]
:Difficulty: Easy
:END:
** Problem
Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.

Example:
#+BEGIN_EXAMPLE
Given a binary tree

          1
         / \
        2   3
       / \
      4   5
Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].
#+END_EXAMPLE

*Note:* The length of path between two nodes is represented by the number of edges between them.
* 547 Friend Circles :DFS:UnionFind:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/friend-circles/description/][leetcode]]
:END:
** Problem
There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.

Given a N*N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.

Example 1:
#+BEGIN_EXAMPLE
Input:
[[1,1,0],
 [1,1,0],
 [0,0,1]]
Output: 2
Explanation:The 0th and 1st students are direct friends, so they are in a friend circle.
The 2nd student himself is in a friend circle. So return 2.
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input:
[[1,1,0],
 [1,1,1],
 [0,1,1]]
Output: 1
Explanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends,
so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1.
#+END_EXAMPLE

*Constraints:*
- 1 <= N <= 200
- M[i][i] == 1
- M[i][j] == M[j][i]
* 572 Subtree of Another Tree :Tree:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/subtree-of-another-tree/][leetcode]]
:END:
** Problem
Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node's descendants. The tree s could also be considered as a subtree of itself.

Example 1:
#+BEGIN_EXAMPLE
Given tree s:

     3
    / \
   4   5
  / \
 1   2
Given tree t:
   4
  / \
 1   2
Return true, because t has the same structure and node values with a subtree of s.
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Given tree s:

     3
    / \
   4   5
  / \
 1   2
    /
   0
Given tree t:
   4
  / \
 1   2
Return false.
#+END_EXAMPLE

* 605 Can Place Flowers :Array:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/can-place-flowers/description/][leetcode]]
:END:
** Problem
Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die.

Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule.

Example 1:
#+BEGIN_EXAMPLE
Input: flowerbed = [1,0,0,0,1], n = 1
Output: True
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: flowerbed = [1,0,0,0,1], n = 2
Output: False
#+END_EXAMPLE

*Note:*
The input array won't violate no-adjacent-flowers rule.
The input array size is in the range of [1, 20000].
n is a non-negative integer which won't exceed the input array size.
* 617 Merge Two Binary Trees :Tree:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/merge-two-binary-trees/][leetcode]]
:END:
** Problem
Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.

You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.

Example 1:
#+BEGIN_EXAMPLE

Input:
	Tree 1                     Tree 2
          1                         2
         / \                       / \
        3   2                     1   3
       /                           \   \
      5                             4   7
Output:
Merged tree:
	     3
	    / \
	   4   5
	  / \   \
	 5   4   7

#+END_EXAMPLE

Note: The merging process must start from the root nodes of both trees.
** Solution
* 637 Average of Levels in Binary Tree :Tree:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/average-of-levels-in-binary-tree/][leetcode]]
:END:
** Problem
Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.
#+BEGIN_EXAMPLE
Example 1:
Input:
    3
   / \
  9  20
    /  \
   15   7
Output: [3, 14.5, 11]
Explanation:
The average value of nodes on level 0 is 3,  on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].
#+END_EXAMPLE

*Note:*
- The range of node's value is in the range of 32-bit signed integer.

* 646 Maximum Length of Pair Chain :DP:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/maximum-length-of-pair-chain/description/][leetcode]]
:END:
** Problem
You are given n pairs of numbers. In every pair, the first number is always smaller than the second number.

Now, we define a pair (c, d) can follow another pair (a, b) if and only if b < c. Chain of pairs can be formed in this fashion.

Given a set of pairs, find the length longest chain which can be formed. You needn't use up all the given pairs. You can select pairs in any order.

Example 1:
#+BEGIN_EXAMPLE
Input: [[1,2], [2,3], [3,4]]
Output: 2
Explanation: The longest chain is [1,2] -> [3,4]
#+END_EXAMPLE

*Note:*
- The number of given pairs will be in the range [1, 1000].

* 663 Sum of Square numbers :Math:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/sum-of-square-numbers/description/][leetcode]]
:END:
** Problem
Given a non-negative integer c, your task is to decide whether there're two integers a and b such that a2 + b2 = c.

Example 1:
#+BEGIN_EXAMPLE
Input: 50
Output: True
Explanation: 1 * 1 + 2 * 2 = 5
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: 3
Output: False
#+END_EXAMPLE
* 665 Non-decreasing Array :Array:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/non-decreasing-array/description/][leetcode]]
:END:
** Problem
Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element.

We define an array is non-decreasing if nums[i] <= nums[i + 1] holds for every i (0-based) such that (0 <= i <= n - 2).


Example 1:
#+BEGIN_EXAMPLE
Input: nums = [4,2,3]
Output: true
Explanation: You could modify the first 4 to 1 to get a non-decreasing array.
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: nums = [4,2,1]
Output: false
Explanation: You can't get a non-decreasing array by modify at most one element.
#+END_EXAMPLE

*Constraints:*

- 1 <= n <= 10 ^ 4
- - 10 ^ 5 <= nums[i] <= 10 ^ 5
* 671 Second Minimum Node In a Binary Tree :Array:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/][leetcode]]
:END:
** Problem
Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes. More formally, the property root.val = min(root.left.val, root.right.val) always holds.

Given such a binary tree, you need to output the second minimum value in the set made of all the nodes' value in the whole tree.

If no such second minimum value exists, output -1 instead.

Example 1:
#+BEGIN_EXAMPLE
Input: root = [2,2,5,null,null,5,7]
Output: 5
Explanation: The smallest value is 2, the second smallest value is 5.
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: root = [2,2,2]
Output: -1
Explanation: The smallest value is 2, but there isn't any second smallest value.
#+END_EXAMPLE

*Constraints:*
- The number of nodes in the tree is in the range [1, 25].
- 1 <= Node.val <= 231 - 1
- root.val == min(root.left.val, root.right.val) for each internal node of the tree.
* 680 Valid Palindrome II :String:TwoPointers:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/valid-palindrome-ii/submissions/][leetcode]]
:END:
** Problem
Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome.

Example 1:
#+BEGIN_EXAMPLE
Input: "aba"
Output: True
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: "abca"
Output: True
Explanation: You could delete the character 'c'.
#+END_EXAMPLE

*Note:*
The string will only contain lowercase characters a-z. The maximum length of the string is 50000.
* 687 Longest Univalue Path :Tree:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/longest-univalue-path/][leetcode]]
:END:
** Problem
Given the root of a binary tree, return the length of the longest path, where each node in the path has the same value. This path may or may not pass through the root.

The length of the path between two nodes is represented by the number of edges between them.


Example 1:
#+BEGIN_EXAMPLE
Input: root = [5,4,5,1,1,5]
Output: 2
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: root = [1,4,5,4,4,5]
Output: 2
#+END_EXAMPLE


*Constraints:*
- The number of nodes in the tree is in the range [0, 104].
- -1000 <= Node.val <= 1000
- The depth of the tree will not exceed 1000.
** Solution
Solution in [[file:687_Longest_Univalue_Path/Java/Solution.java::class Solution {][Java]].

* 695 Max Area of Island :DFS:Array:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/max-area-of-island/][leetcode]]
:END:
** Problem
Given a non-empty 2D array grid of 0's and 1's, an island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.

Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)

Example 1:
#+BEGIN_EXAMPLE

[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
[[0,0,0,0,0,0,0,0]]
Given the above grid, return 0.
#+END_EXAMPLE

Note: The length of each dimension in the given grid does not exceed 50.
* 763 Partition Labels :TwoPointers:Greedy:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/partition-labels/description/][leetcode]]
:END:
** Problem
A string S of lowercase English letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.

Example 1:
#+BEGIN_EXAMPLE
Input: S = "ababcbacadefegdehijhklij"
Output: [9,7,8]
Explanation:
The partition is "ababcbaca", "defegde", "hijhklij".
This is a partition so that each letter appears in at most one part.
A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits S into less parts.
#+END_EXAMPLE

*Note:*
- S will have length in range [1, 500].
- S will consist of lowercase English letters ('a' to 'z') only.
* 714 Best Time to Buy and Sell Stock with Transaction Fee :DP:
:PROPERTIES:
:Link:     [[https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/][leetcode]]
:Difficulty: Medium
:END:
** Problem
Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee.

You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)

Return the maximum profit you can make.

Example 1:
#+BEGIN_EXAMPLE
Input: prices = [1, 3, 2, 8, 4, 9], fee = 2
Output: 8
Explanation: The maximum profit can be achieved by:
Buying at prices[0] = 1
Selling at prices[3] = 8
Buying at prices[4] = 4
Selling at prices[5] = 9
The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
#+END_EXAMPLE

*Note:*
- 0 < prices.length <= 50000.
- 0 < prices[i] < 50000.
- 0 <= fee < 50000.
* 744 Find Smallest Letter Greater Than Target :BinarySearch:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/find-smallest-letter-greater-than-target/description/][leetcode]]
:END:
** Problem
Given a list of sorted characters letters containing only lowercase letters, and given a target letter target, find the smallest element in the list that is larger than the given target.

Letters also wrap around. For example, if the target is target = 'z' and letters = ['a', 'b'], the answer is 'a'.

Examples:
#+BEGIN_EXAMPLE
Input:
letters = ["c", "f", "j"]
target = "a"
Output: "c"

Input:
letters = ["c", "f", "j"]
target = "c"
Output: "f"

Input:
letters = ["c", "f", "j"]
target = "d"
Output: "f"

Input:
letters = ["c", "f", "j"]
target = "g"
Output: "j"

Input:
letters = ["c", "f", "j"]
target = "j"
Output: "c"

Input:
letters = ["c", "f", "j"]
target = "k"
Output: "c"
#+END_EXAMPLE

*Note:*
1. letters has a length in range [2, 10000].
2. letters consists of lowercase letters, and contains at least 2 unique letters.
3. target is a lowercase letter.
* 922 Sort Array by Parity II :Array:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/sort-array-by-parity-ii/][leetcode]]
:END:
** Problem
Given an array A of non-negative integers, half of the integers in A are odd, and half of the integers are even.

Sort the array so that whenever A[i] is odd, i is odd; and whenever A[i] is even, i is even.

You may return any answer array that satisfies this condition.


Example 1:
#+BEGIN_EXAMPLE
Input: [4,2,5,7]
Output: [4,5,2,7]
Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.
#+END_EXAMPLE

*Note:*
- 2 <= A.length <= 20000
- A.length % 2 == 0
- 0 <= A[i] <= 1000
* 1091 Shortest Path in Binary Matrix :BFS:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/shortest-path-in-binary-matrix/][leetcode]]
:END:
** Problem
n an N by N square grid, each cell is either empty (0) or blocked (1).

A clear path from top-left to bottom-right has length k if and only if it is composed of cells C_1, C_2, ..., C_k such that:

Adjacent cells C_i and C_{i+1} are connected 8-directionally (ie., they are different and share an edge or corner)
C_1 is at location (0, 0) (ie. has value grid[0][0])
C_k is at location (N-1, N-1) (ie. has value grid[N-1][N-1])
If C_i is located at (r, c), then grid[r][c] is empty (ie. grid[r][c] == 0).
Return the length of the shortest such clear path from top-left to bottom-right.  If such a path does not exist, return -1.

Example 1:
#+BEGIN_EXAMPLE

Input: [[0,1],[1,0]]

Output: 2

#+END_EXAMPLE


Example 2:
#+BEGIN_EXAMPLE
Input: [[0,0,0],[1,1,0],[1,1,0]]


Output: 4
#+END_EXAMPLE


*Note:*
1. 1 <= grid.length == grid[0].length <= 100
2. grid[r][c] is 0 or 1
* 1143 Longest Common Subsequence :DP:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/longest-common-subsequence/][leetcode]]
:END:
** Problem
Given two strings text1 and text2, return the length of their longest common subsequence.

A subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, "ace" is a subsequence of "abcde" while "aec" is not). A common subsequence of two strings is a subsequence that is common to both strings.


If there is no common subsequence, return 0.

Example 1:
#+BEGIN_EXAMPLE
Input: text1 = "abcde", text2 = "ace"
Output: 3
Explanation: The longest common subsequence is "ace" and its length is 3.
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: text1 = "abc", text2 = "abc"
Output: 3
Explanation: The longest common subsequence is "abc" and its length is 3.
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE

Input: text1 = "abc", text2 = "def"
Output: 0
Explanation: There is no such common subsequence, so the result is 0.
#+END_EXAMPLE

*Constraints:*
- 1 <= text1.length <= 1000
- 1 <= text2.length <= 1000
- The input strings consist of lowercase English characters only.
** Solution
Solution in [[file:1143_Longest_Common_Subsequence/Java/Solution.java][Java]].
