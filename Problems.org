#+TITLE: Leetcode Problems
#+AUTHOR: Marvin
#+PROPERTY: LOGGING nil

* 001 Two Sum :Array:HashTable:
:PROPERTIES:
:Difficulty: Easy
:END:
** Problem

Given an array of integers, return *indices* of the two numbers such that they
add up to a specific target.

You may assume that each input would have *exactly* one solution, and you may
not use the same element twice.

*Example*
#+BEGIN_EXAMPLE
Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,

return [0, 1].
#+END_EXAMPLE

** Solution
*** Brute Force
We can easily have a quick solution based on brute force way - two level nested
loops.

Pseudo code:
1. Outer loop, record index as =i=
2. Innser loop, record index as =j=
   - compare =targe= and =nums[i]+nums[j]=
   - if equal, exit the loop, return =i= & =j=
   - else, continue the loop

The time complexity of the brute force way is O(n^2), which is not good.
*** Hashmap
We can then have an idea that there's no need for two loops, if we can have a
hashmap of the numbers, we just need one loop, with =target-currentNumber=, we
can immediately get the index of second number. We only need 2n as for time
complexity. The first time of loop is to build the hashmap, we then have the
second loop to compare the target and retrieve the indices.

Pseudo code:
1. First loop - build hashmap with key equal to number and value to index
2. Second loop - let =taget_num = target - nums[i]=, retrieve second index from
   the hashmap, if =map[target_numer]= exist, then return it as second index,
   else continue the loop.

The time complexity is O(n)

*** Improved Hashmap
We then come with the idea that there's no need to prebuid the hashmap, we could
combine the building of hashmap and search target within exact one loop, the
performance then could be further improved.

Pseudo code:
1. Build am empty hashmap =map=
2. Within the loop of nums
   - let =target_num = target - nums[i]=
   - Check if target-num exist in map, return indices if exist
   - if not, put current value and index into the map.

* 002 Add Two Numbers :LinkedList:
:PROPERTIES:
:Difficulty: Medium
:END:
** Problem

You are given two non-empty linked lists representing two non-negative integers.
The digits are stored in reverse order and each of their nodes contain a single
digit. Add the two numbers and return it as a linked list.


You may assume the two numbers do not contain any leading zero, except the
number 0 itself.

*Example*
#+BEGIN_EXAMPLE
Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)

Output: 7 -> 0 -> 8

Explanation: 342 + 465 = 807.
#+END_EXAMPLE

** Solution
This problem is relatively simply if you are familiar with the basic data
structure linked list.

Just need to visit two linked list, have them sum up, in the meantime, need to
care about whether one of the linked list is empty, and whether the sum in each
time is bigger than 9.
* 003 Longest Substring :String:TwoPointers:
:PROPERTIES:
:Difficulty: Medium
:END:
** Problem
Given a string, find the length of the longest substring without repeating characters.
*Example 1*
#+BEGIN_EXAMPLE
Input: "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
#+END_EXAMPLE

*Example 2*
#+BEGIN_EXAMPLE
Input: "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
#+END_EXAMPLE

*Example 3*
#+BEGIN_EXAMPLE
Input: "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Note that the answer must be a substring, "pwke" is a subsequence and not a substring.
#+END_EXAMPLE

** Solution
A typical two pointer or slide window problem.
The algorithm describes in below:
1. Define front pointer fp at position 0, define back pointer bp at position 0.
2. Check whether next character of fp has repeat character between fp and bp.
3. If not, move fp forward; And back to step 2
4. If yes,
   - compare current string length with already saved maximum string, if
     exceeds, then save current string to maxmum string
   - move bp to next character of the repeat character
   - move fp to next character, and back to step 2

The tricky part is how to detect whether the next character is repeat between bp
and fp, we could build a hash map to store the characters between bp and fp with
its position, so that the check time is constant. In this case, the space
complexity is O(n) time complexity is n,
* 004 Median of Two Sorted Arrays :Array:BinarySearch:DivedAndConquer:
:PROPERTIES:
:Difficulty: Hard
:Link:     https://leetcode.com/problems/median-of-two-sorted-arrays/
:END:
** Problem
There are two sorted arrays nums1 and nums2 of size m and n respectively.

Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

You may assume nums1 and nums2 cannot be both empty.

*Example 1:*
#+BEGIN_EXAMPLE
nums1 = [1, 3]
nums2 = [2]

The median is 2.0
#+END_EXAMPLE

*Example 2:*
#+BEGIN_EXAMPLE
nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5
#+END_EXAMPLE

** Solution
The straight forward idea is to repeatly minus the divisor from dividend according to definition of division. It surely works, the time complexity is n(divisor/dividend).

We can, somehow, think about that with repeatly do the step of ~let sum=divide, do sum += sum~, we could accelarate the minus. The next question is how we count how many times we've done the minus, answer is we setup another synced stack to calculate the repeat double of *one*. So that when we finish the minus, we just need to check the stack of *one*, and sum all of them.

*Pseudo code*:
1. Build a two dimension array, the initial two values are 1 & divide.
2. Double previous two values via plus the same, compare the doubled divide stack with dividend.
3. If less than dividend then store it in next array position. Continue with step 2.
4. Else, compare current (before doubled) divide value, check if < dividend.
5. If Yes, divident -= current summed divide value, array backwards one, sum the index stack
6. Else, array backwards one and continue with step 3

With step 4 - 6, the loop end condition should be dividend < divide.
Exception Case:
1. Dividend and divisor could be negative
2. Could be overflow during calcualtion.

* 005 Longest Palindromic Substring
:PROPERTIES:
:Difficulty: Medium
:END:
** Problem
Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.
*Example 1*
#+BEGIN_EXAMPLE
Input: "babad"
Output: "bab"
Note: "aba" is also a valid answer.
#+END_EXAMPLE

*Example 2*
#+BEGIN_EXAMPLE
Input: "cbbd"
Output: "bb"
#+END_EXAMPLE

** Solution
* 006 ZigZag Conversion
:PROPERTIES:
:Difficulty: Medium
:END:
** Problem
The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

P   A   H   N
A P L S I I G
Y   I   R
And then read line by line: "PAHNAPLSIIGYIR"

Write the code that will take a string and make this conversion given a number of rows:

string convert(string s, int numRows);
*Example 1*
#+BEGIN_EXAMPLE
Input: s = "PAYPALISHIRING", numRows = 3
Output: "PAHNAPLSIIGYIR"
#+END_EXAMPLE

*Example 2*
#+BEGIN_EXAMPLE
Input: s = "PAYPALISHIRING", numRows = 4
Output: "PINALSIGYAHRPI"
Explanation:

P     I    N
A   L S  I G
Y A   H R
P     I
#+END_EXAMPLE


** Solution
* 007 Reverse Integer :Math:
:PROPERTIES:
:Difficulty: Easy
:END:
** Problem
Given a 32-bit signed integer, reverse digits of an integer.

*Example 1*
#+BEGIN_EXAMPLE
Input: 123
Output: 321
Example 2:
#+END_EXAMPLE

*Example 2*
#+BEGIN_EXAMPLE
Input: 120
Output: 21
#+END_EXAMPLE

Note:
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.
* 008 String to Integer (atoi)
:PROPERTIES:
:Difficulty: Medium
:END:
** Problem
Implement atoi which converts a string to an integer.

The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.

The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.

If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.

If no valid conversion could be performed, a zero value is returned.

*Note*:

Only the space character ' ' is considered as whitespace character.
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.

*Example 1*:
#+BEGIN_EXAMPLE
Input: "42"
Output: 42
#+END_EXAMPLE

*Example 2*:
#+BEGIN_EXAMPLE
Input: "   -42"
Output: -42
Explanation: The first non-whitespace character is '-', which is the minus sign.
             Then take as many numerical digits as possible, which gets 42.
#+END_EXAMPLE

*Example 3*:
#+BEGIN_EXAMPLE
Input: "4193 with words"
Output: 4193
Explanation: Conversion stops at digit '3' as the next character is not a numerical digit.
#+END_EXAMPLE

*Example 4*:
#+BEGIN_EXAMPLE
Input: "words and 987"
Output: 0
Explanation: The first non-whitespace character is 'w', which is not a numerical
             digit or a +/- sign. Therefore no valid conversion could be performed.
#+END_EXAMPLE

*Example 5*:
#+BEGIN_EXAMPLE
Input: "-91283472332"
Output: -2147483648
Explanation: The number "-91283472332" is out of the range of a 32-bit signed integer.
             Thefore INT_MIN (−231) is returned.
#+END_EXAMPLE
** Solution

* 009 Palindrome Number :Math:
:PROPERTIES:
:Difficulty: Easy
:END:
** Problem
Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.

*Example 1:*
#+BEGIN_EXAMPLE
Input: 121
Output: true
#+END_EXAMPLE

*Example 2:*
#+BEGIN_EXAMPLE
Input: -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
#+END_EXAMPLE

*Example 3:*
#+BEGIN_EXAMPLE
Input: 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.
#+END_EXAMPLE
** Solution
* 010 Regular Expression Matching :String:DP:Backtracking:
:PROPERTIES:
:Difficulty: Hard
:END:
** Problem
Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'.

'.' Matches any single character.
'*' Matches zero or more of the preceding element.
The matching should cover the entire input string (not partial).

Note:

s could be empty and contains only lowercase letters a-z.
p could be empty and contains only lowercase letters a-z, and characters like . or *.
Example 1:
#+BEGIN_EXAMPLE
Input:
s = "aa"
p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input:
s = "aa"
p = "a*"
Output: true
Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE
Input:
s = "ab"
p = ".*"
Output: true
Explanation: ".*" means "zero or more (*) of any character (.)".
#+END_EXAMPLE

Example 4:
#+BEGIN_EXAMPLE
Input:
s = "aab"
p = "c*a*b"
Output: true
Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches "aab".
#+END_EXAMPLE

Example 5:
#+BEGIN_EXAMPLE
Input:
s = "mississippi"
p = "mis*is*p*."
Output: false
#+END_EXAMPLE

** Solution
* 011 Container With Most Water :Array:TwoPointers:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/container-with-most-water/][leetcode]]
:END:
** Problem
Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.

*Note*: You may not slant the container and n is at least 2.


The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.

Example:
#+BEGIN_EXAMPLE
Input: [1,8,6,2,5,4,8,3,7]
Output: 49
#+END_EXAMPLE
* 012 Integer to Roman :Math:String:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/integer-to-roman/][leetcode]]
:END:
** Problem
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9.
X can be placed before L (50) and C (100) to make 40 and 90.
C can be placed before D (500) and M (1000) to make 400 and 900.
Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.

Example 1:
#+BEGIN_EXAMPLE
Input: 3
Output: "III"
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: 4
Output: "IV"
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE
Input: 9
Output: "IX"
#+END_EXAMPLE

Example 4:
#+BEGIN_EXAMPLE
Input: 58
Output: "LVIII"
Explanation: L = 50, V = 5, III = 3.
#+END_EXAMPLE

Example 5:
#+BEGIN_EXAMPLE
Input: 1994
Output: "MCMXCIV"
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
#+END_EXAMPLE

* 013 Roman to Integer :Math:String:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/roman-to-integer/][leetcode]]
:END:
** Problem
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
#+BEGIN_QUOTE
Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
#+END_QUOTE

For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9.
X can be placed before L (50) and C (100) to make 40 and 90.
C can be placed before D (500) and M (1000) to make 400 and 900.
Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.

Example 1:
#+BEGIN_EXAMPLE
Input: "III"
Output: 3
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: "IV"
Output: 4
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE
Input: "IX"
Output: 9
#+END_EXAMPLE

Example 4:
#+BEGIN_EXAMPLE
Input: "LVIII"
Output: 58
Explanation: L = 50, V= 5, III = 3.
#+END_EXAMPLE

Example 5:
#+BEGIN_EXAMPLE
Input: "MCMXCIV"
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
#+END_EXAMPLE
* 014 Longest Common Prefix :String:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/longest-common-prefix/][leetcode]]
:END:
** Problem
Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string "".

Example 1:
#+BEGIN_EXAMPLE
Input: ["flower","flow","flight"]
Output: "fl"
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: ["dog","racecar","car"]
Output: ""
Explanation: There is no common prefix among the input strings.
#+END_EXAMPLE

*Note:*

All given inputs are in lowercase letters ~a-z~.

* 029 Divide Two Integers :BinarySearch:
:PROPERTIES:
:Difficulty: Medium
:END:
** Problem
Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.

Return the quotient after dividing dividend by divisor.

The integer division should truncate toward zero, which means losing its fractional part. For example, truncate(8.345) = 8 and truncate(-2.7335) = -2.
*Example 1*
#+BEGIN_EXAMPLE
Input: dividend = 10, divisor = 3
Output: 3
Explanation: 10/3 = truncate(3.33333..) = 3.
#+END_EXAMPLE

*Example 2*
#+BEGIN_EXAMPLE
Input: dividend = 7, divisor = -3
Output: -2
Explanation: 7/-3 = truncate(-2.33333..) = -2.
#+END_EXAMPLE

** Solution
* 032 Longest Valid Parentheses :String:DP:
:PROPERTIES:
:Difficulty: Hard
:Link:    [[https://leetcode.com/problems/longest-valid-parentheses/][leetcode]]
:END:
** Problem
Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.

Example 1:
#+BEGIN_EXAMPLE
Input: "(()"
Output: 2
Explanation: The longest valid parentheses substring is "()"
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: ")()())"
Output: 4
Explanation: The longest valid parentheses substring is "()()"
#+END_EXAMPLE
* 062 Unique Paths :DP:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/unique-paths/description/][leetcode]]
:END:
** Problem
A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).
[[*Problem][Problem]]

How many possible unique paths are there?

*Example 1:*
#+BEGIN_EXAMPLE
Input: m = 3, n = 7
Output: 28
#+END_EXAMPLE

*Example 2:*
#+BEGIN_EXAMPLE
Input: m = 3, n = 2
Output: 3
Explanation:
From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Down -> Down
2. Down -> Down -> Right
3. Down -> Right -> Down
#+END_EXAMPLE


*Example 3:*
#+BEGIN_EXAMPLE
Input: m = 7, n = 3
Output: 28
#+END_EXAMPLE


*Example 4:*
#+BEGIN_EXAMPLE
Input: m = 3, n = 3
Output: 6
#+END_EXAMPLE

* 064 Minimum Path Sum :DP:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/minimum-path-sum/description/][leetcode]]
:END:
** Problem
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.

Example:
#+BEGIN_EXAMPLE
Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1→3→1→1→1 minimizes the sum.
#+END_EXAMPLE

* 070 Climbing Stairs :DP:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/climbing-stairs/description/][leetcode]]
:END:
** Problem
You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

*Example 1:*
#+BEGIN_EXAMPLE
Input: 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
#+END_EXAMPLE

*Example 2:*
#+BEGIN_EXAMPLE
Input: 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
#+END_EXAMPLE

*Constraints*:

1 <= n <= 45
** Solution
Source code in [[file:070_Climbing_Stairs/Java/Solution.java::class Solution{][Java]].
* 075 Sort Colors :Array:TwoPointers:Sort:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/sort-colors/description/][leetcode]]
:END:
** Problem
Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.

Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

Follow up:

Could you solve this problem without using the library's sort function?
Could you come up with a one-pass algorithm using only O(1) constant space?


Example 1:
#+BEGIN_EXAMPLE
Input: nums = [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: nums = [2,0,1]
Output: [0,1,2]
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE
Input: nums = [0]
Output: [0]
#+END_EXAMPLE

Example 4:
#+BEGIN_EXAMPLE
Input: nums = [1]
Output: [1]
#+END_EXAMPLE

*Constraints:*
#+BEGIN_QUOTE
n == nums.length
1 <= n <= 300
nums[i] is 0, 1, or 2.
#+END_QUOTE

* 088 Merge Sorted Array :TwoPointers:Array:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/merge-sorted-array/][leetcode]]
:END:
** Problem
Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.

*Note:*
- The number of elements initialized in nums1 and nums2 are m and n respectively.
- You may assume that nums1 has enough space (size that is equal to m + n) to hold additional elements from nums2.

*Example:*
#+BEGIN_EXAMPLE
Input:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

Output: [1,2,2,3,5,6]
#+END_EXAMPLE

Constraints:
#+BEGIN_QUOTE
-10^9 <= nums1[i], nums2[i] <= 10^9
nums1.length == m + n
nums2.length == n
#+END_QUOTE

* 091 Decode Ways :String:DP:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/decode-ways/description/][leetcode]]
:END:
** Problem
A message containing letters from A-Z is being encoded to numbers using the following mapping:
#+BEGIN_QUOTE
'A' -> 1
'B' -> 2
...
'Z' -> 26
#+END_QUOTE

Given a non-empty string containing only digits, determine the total number of ways to decode it.

Example 1:
#+BEGIN_EXAMPLE
Input: "12"
Output: 2
Explanation: It could be decoded as "AB" (1 2) or "L" (12).
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: "226"
Output: 3
Explanation: It could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).
#+END_EXAMPLE
* 121 Best Time to Buy and Sell Stock
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/][leetcode]]
:END:
** Problem
Say you have an array for which the ith element is the price of a given stock on day i.

If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.

Note that you cannot sell a stock before you buy one.

Example 1:
#+BEGIN_EXAMPLE
Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
#+END_EXAMPLE
* 122 Best Time to Buy and Sell Stock II
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/][leetcode]]
:END:
** Problem
Say you have an array prices for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).

Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).

Example 1:
#+BEGIN_EXAMPLE
Input: [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
             engaging multiple transactions at the same time. You must sell before buying again.
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE
Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
#+END_EXAMPLE

*Constraints:*
- 1 <= prices.length <= 3 * 10 ^ 4
- 0 <= prices[i] <= 10 ^ 4

* 141 Linked List Cycle :TwoPointers:LinkedList:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/linked-list-cycle/][leetcode]]
:END:
** Problem
Given head, the head of a linked list, determine if the linked list has a cycle in it.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.

Return true if there is a cycle in the linked list. Otherwise, return false.

Follow up:

Can you solve it using O(1) (i.e. constant) memory?

Example 1:

[[download:141_Linked_List_Cycle/_20200922_083807circularlinkedlist.png]]

#+BEGIN_EXAMPLE
Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).
#+END_EXAMPLE

Example 2:

[[download:141_Linked_List_Cycle/_20200922_083938circularlinkedlist_test2.png]]

#+BEGIN_EXAMPLE
Input: head = [1,2], pos = 0
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.
#+END_EXAMPLE

Example 3:

[[download:141_Linked_List_Cycle/_20200922_083918circularlinkedlist_test3.png]]

#+BEGIN_EXAMPLE
Input: head = [1], pos = -1
Output: false
Explanation: There is no cycle in the linked list.
#+END_EXAMPLE

* 143 Reorder List :LinkedList:
:PROPERTIES:
:Difficulty: Medium
:END:
:LOGBOOK:
CLOCK: [2020-07-04 Sat 15:24]--[2020-07-04 Sat 17:46] =>  2:22
CLOCK: [2020-07-04 Sat 10:38]--[2020-07-04 Sat 11:50] =>  1:12
:END:
** Problem
Given a singly linked list L: L0→L1→…→Ln-1→Ln,
reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…

You may not modify the values in the list's nodes, only nodes itself may be
changed.

** Example
#+BEGIN_EXAMPLE
Given 1->2->3->4, reorder it to 1->4->2->3.
#+END_EXAMPLE

#+BEGIN_EXAMPLE
Given 1->2->3->4->5, reorder it to 1->5->2->4->3.
#+END_EXAMPLE

** Solution
*** First Try
We first get a reversed linked list, and then we travel the two linked list in
the same time until the value meet (The middle value).
The time complexity will be 2n or O(n), space complexity will be n or O(n).

Question: how we know we should stop, or how shall we know it's middle value.
Answer: It's singly linked list, so we can simple compare with the value, value
from the natual linked list should always left than or equal than the reversed
order one, and at one point, they will meet with the same value, then should
stop the loop.

currL -> L0;
nextL -> L1;
currRL > Ln;

L0->Ln;
currL -> L1;
nextL -> Ln-1;
currRL -> L2;

Failed, reason is the assumption which the linked list is ordered is incorrect,
in this case, we can only do the count for the reverse part. That's quite ugly.
*** Second Try
For linked list, we have so called "fast-slow-pointer", which means we set two
points to do the travesal of the singly linked list, slow pointer goes
one step in one round, while fast pointer goes two steps in one round, so when
fast pointer reach the end, we could imagine that the slow pointer exactly
stopped in the middle of the list.

Second step is, start at the middle position (slow->next), we start to reverse
the list, by the end of this step, we have two list, one is the natual list
pointd by head, the other is reversed from tail pointed by tail.

Last step is to compose the new list with the two lists, it's pretty easy step
to go.
* 167 Two Sum II :Array:TwoPointers:
:PROPERTIES:
:Difficulty: Easy
:END:
** Problem
Given an array of integers that is already sorted in ascending order, find two
numbers such that they add up to a specific target number.

The function twoSum should return indices of the two numbers such that they add
up to the target, where index1 must be less than index2.

*Note*:
- Your returned answers (both index1 and index2) are not zero-based.
- You may assume that each input would have exactly one solution and you may not
  use the same element twice.

*Example 1*
#+BEGIN_EXAMPLE
Input: numbers = [2,7,11,15], target = 9

Output: [1,2]

Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.
#+END_EXAMPLE
** Solution
*** Binary Search
We could of course still use the hasmap solution, which has both time and space
complexity of ~O(n)~. However, since the array is sorted, with the keyword
~sorted~, binary search jump into my mind. In this case, time complexity would
be O(n*log(n)), which is worse, but there's no extra space needed.

Pseudo Code:
#+BEGIN_EXAMPLE
1. Loop the array =numbers= with index =i=:
   - let =y=target-numbers[i]=
   - Do binary search of =y= on =numbers= (low = i)
   - If found, return [i+1,j+1]
#+END_EXAMPLE
*** Two Pointers
Apparently, ~O(n*logn)~ seems is not a good solution. We then can think
something of ~quick sort~, which uses two points, we can adapt the same idea
with keeping no extra space used but lowered the time complexity to ~O(n)~.

Pseudo Code:
#+BEGIN_EXAMPLE
1. Put the =lo= pointer to 0 and =hi= pointer to =lengh-1=
2. Set =y=target-numbers[lo]=, compare and move =hi= until =y>=numbers[hi]=
3. If =y!=numbers[hi]=, move lo forward, and repeat step 2.
#+END_EXAMPLE
* 198 House Robber :DP:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/house-robber/submissions/][leetcode]]
:END:
** Problem
You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.



*Example 1:*
#+BEGIN_EXAMPLE
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.
#+END_EXAMPLE

*Example 2:*
#+BEGIN_EXAMPLE
Input: nums = [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
             Total amount you can rob = 2 + 9 + 1 = 12.

#+END_EXAMPLE

*Constraints:*

0 <= nums.length <= 100
0 <= nums[i] <= 400
** Solution
* 213 House Robber II :DP:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/house-robber-ii/description/][leetcode]]
:END:
** Problem
You are a professional robber planning to rob houses along a street. Each house
has a certain amount of money stashed. All houses at this place are arranged in
a circle. That means the first house is the neighbor of the last one. Meanwhile,
adjacent houses have security system connected and it will automatically contact
the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each
house, determine the maximum amount of money you can rob tonight without
alerting the police.

*Example 1:*
#+BEGIN_EXAMPLE
Input: [2,3,2]
Output: 3
Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),
             because they are adjacent houses.
#+END_EXAMPLE

*Example 2:*
#+BEGIN_EXAMPLE
Input: [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.
#+END_EXAMPLE

** Solution
Similar to Problem 198 House Robber, need additional consideration if the first
house is robbed or not.
* 215 Kth Largest Element in an Array :Heap:DivideAndConquer:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/kth-largest-element-in-an-array/description/][leetcode]]
:END:
** Problem
Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.

Example 1:
#+BEGIN_EXAMPLE
Input: [3,2,1,5,6,4] and k = 2
Output: 5
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: [3,2,3,1,2,4,5,5,6] and k = 4
Output: 4
#+END_EXAMPLE

*Note:*
You may assume k is always valid, 1 ≤ k ≤ array's length.
* 279 Perfect Squares :Math:DP:BFS:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/perfect-squares/description/][leetcode]]
:END:
** Problem
Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.

Example 1:
#+BEGIN_EXAMPLE
Input: n = 12
Output: 3
Explanation: 12 = 4 + 4 + 4.
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: n = 13
Output: 2
Explanation: 13 = 4 + 9.
#+END_EXAMPLE

* 303 Range Sum Query - Immutable :DP:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/range-sum-query-immutable/description/][leetcode]]
:END:
** Problem
Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.

Example:
#+BEGIN_EXAMPLE
Given nums = [-2, 0, 3, -5, 2, -1]

sumRange(0, 2) -> 1
sumRange(2, 5) -> -1
sumRange(0, 5) -> -3
#+END_EXAMPLE

*Constraints:*
- You may assume that the array does not change.
- There are many calls to sumRange function.
- 0 <= nums.length <= 10^4
- -10^5 <= nums[i] <= 10^5
- 0 <= i <= j < nums.length
* 343 Integer Break :DP:Math:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/integer-break/description/][leetcode]]
:END:
** Problem
Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of  those integers. Return the maximum product you can get.

Example 1:
#+BEGIN_EXAMPLE
Input: 2
Output: 1
Explanation: 2 = 1 + 1, 1 × 1 = 1.
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: 10
Output: 36
Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36.
Note: You may assume that n is not less than 2 and not larger than 58.
#+END_EXAMPLE
* 345 Reverse Vowels of a String :TwoPointers:String:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/reverse-vowels-of-a-string/description/][leetcode]]
:END:
** Problem
Write a function that takes a string as input and reverse only the vowels of a string.

Example 1:
#+BEGIN_EXAMPLE
Input: "hello"
Output: "holle"
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: "leetcode"
Output: "leotcede"
#+END_EXAMPLE

*Note:*
The vowels does not include the letter "y".
* 347 Top K Frequent Elements :HashTable:Heap:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/top-k-frequent-elements/description/][leetcode]]
:END:
** Problem
Given a non-empty array of integers, return the k most frequent elements.

Example 1:
#+BEGIN_EXAMPLE
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: nums = [1], k = 1
Output: [1]
#+END_EXAMPLE

*Note:*

- You may assume k is always valid, 1 ≤ k ≤ number of unique elements.
- Your algorithm's time complexity must be better than O(n log n), where n is the array's size.
- It's guaranteed that the answer is unique, in other words the set of the top k frequent elements is unique.
- You can return the answer in any order.
* 392 Is Subsequence :BinarySearch:DP:Greedy:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/is-subsequence/description/][leetcode]]
:END:
** Problem
Given a string s and a string t, check if s is subsequence of t.

A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ace" is a subsequence of "abcde" while "aec" is not).

Follow up:
If there are lots of incoming S, say S1, S2, ... , Sk where k >= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?

Credits:
Special thanks to @pbrother for adding this problem and creating all test cases.

Example 1:
#+BEGIN_EXAMPLE
Input: s = "abc", t = "ahbgdc"
Output: true
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: s = "axc", t = "ahbgdc"
Output: false
#+END_EXAMPLE

*Constraints:*
- 0 <= s.length <= 100
- 0 <= t.length <= 10^4
- Both strings consists only of lowercase characters.
* 406 Queue Reconstruction by Height :Greedy:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/queue-reconstruction-by-height/description/][leetcode]]
:END:
** Problem
Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue.

*Note:*
The number of people is less than 1,100.


Example
#+BEGIN_EXAMPLE
Input:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

Output:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
#+END_EXAMPLE

* 413 Arithmetic Slices :DP:Math:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/arithmetic-slices/description/][leetcode]]
:END:
** Problem
A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.

For example, these are arithmetic sequences:

1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9
The following sequence is not arithmetic.

1, 1, 2, 5, 7

A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 <= P < Q < N.

A slice (P, Q) of the array A is called arithmetic if the sequence:
A[P], A[P + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 < Q.

The function should return the number of arithmetic slices in the array A.


*Example:*
#+BEGIN_EXAMPLE
A = [1, 2, 3, 4]

return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.
#+END_EXAMPLE
* 435 Non-overlapping Intervals :Greedy:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/non-overlapping-intervals/description/][leetcode]]
:END:
** Problem
Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.

Example 1:
#+BEGIN_EXAMPLE
Input: [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: [1,3] can be removed and the rest of intervals are non-overlapping.
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: [[1,2],[1,2],[1,2]]
Output: 2
Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE
Input: [[1,2],[2,3]]
Output: 0
Explanation: You don't need to remove any of the intervals since they're already non-overlapping.
#+END_EXAMPLE

*Note:*
#+BEGIN_QUOTE
1. You may assume the interval's end point is always bigger than its start point.
2. Intervals like [1,2] and [2,3] have borders "touching" but they don't overlap each other.
#+END_QUOTE

* 445 Add Two Numbers II :LinkedList:
:PROPERTIES:
:Difficulty: Medium
:END:
** Problem
You are given two non-empty linked lists representing two non-negative
integers. The most significant digit comes first and each of their nodes contain
a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Follow up:
What if you cannot modify the input lists? In other words, reversing the lists is not allowed.

*Example 1*
#+BEGIN_EXAMPLE
Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 8 -> 0 -> 7
#+END_EXAMPLE
** Solution
One option would be reverse the two linked list, then we can follow the same solution as in problem 002 Add Two numbers.
In this case, what we can do is the reverse of linked list. This is easy to do.

While the follow up says, we cannot reverse the list, so we need to figure other option. The similar function would be use a StackList.
* 451 Sort Characters By Frequency :HashTable:Heap:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/sort-characters-by-frequency/description/][leetcode]]
:END:
** Problem
Given a string, sort it in decreasing order based on the frequency of characters.

Example 1:
#+BEGIN_EXAMPLE
Input:
"tree"

Output:
"eert"

Explanation:
'e' appears twice while 'r' and 't' both appear once.
So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input:
"cccaaa"

Output:
"cccaaa"

Explanation:
Both 'c' and 'a' appear three times, so "aaaccc" is also a valid answer.
Note that "cacaca" is incorrect, as the same characters must be together.
Example 3:

Input:
"Aabb"

Output:
"bbAa"

Explanation:
"bbaA" is also a valid answer, but "Aabb" is incorrect.
Note that 'A' and 'a' are treated as two different characters.
#+END_EXAMPLE
* 452 Minimum Number of Arrows to Burst Balloons
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/][leetcode]]
:END:
** Problem
There are some spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter, and hence the x-coordinates of start and end of the diameter suffice. The start is always smaller than the end.

An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps traveling up infinitely.

Given an array points where points[i] = [xstart, xend], return the minimum number of arrows that must be shot to burst all balloons.



Example 1:
#+BEGIN_EXAMPLE
Input: points = [[10,16],[2,8],[1,6],[7,12]]
Output: 2
Explanation: One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: points = [[1,2],[3,4],[5,6],[7,8]]
Output: 4
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE
Input: points = [[1,2],[2,3],[3,4],[4,5]]
Output: 2
#+END_EXAMPLE

Example 4:
#+BEGIN_EXAMPLE
Input: points = [[1,2]]
Output: 1
#+END_EXAMPLE

Example 5:
#+BEGIN_EXAMPLE
Input: points = [[2,3],[2,3]]
Output: 1
#+END_EXAMPLE

*Constraints:*
- 0 <= points.length <= 10^4
- points.length == 2
- -2^31 <= x_start < x_end <= 2^31 - 1

* 455 Assign Cookies :Greedy:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/assign-cookies/][leetcode]]
:END:
** Problem
Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj >= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.

Note:
You may assume the greed factor is always positive.
You cannot assign more than one cookie to one child.

Example 1:
#+BEGIN_EXAMPLE
Input: [1,2,3], [1,1]

Output: 1

Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3.
And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.
You need to output 1.
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: [1,2], [1,2,3]

Output: 2

Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2.
You have 3 cookies and their sizes are big enough to gratify all of the children,
You need to output 2.
#+END_EXAMPLE

* 542 Longest Word in Dictionary Through Deleting :TwoPointers:Sort:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/description/][leetcode]]
:END:
** Problem
Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.

Example 1:
#+BEGIN_EXAMPLE
Input:
s = "abpcplea", d = ["ale","apple","monkey","plea"]

Output:
"apple"
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input:
s = "abpcplea", d = ["a","b","c"]

Output:
"a"
#+END_EXAMPLE

*Note:*

All the strings in the input will only contain lower-case letters.
The size of the dictionary won't exceed 1,000.
The length of all the strings in the input won't exceed 1,000.
* 605 Can Place Flowers :Array:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/can-place-flowers/description/][leetcode]]
:END:
** Problem
Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die.

Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule.

Example 1:
#+BEGIN_EXAMPLE
Input: flowerbed = [1,0,0,0,1], n = 1
Output: True
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: flowerbed = [1,0,0,0,1], n = 2
Output: False
#+END_EXAMPLE

*Note:*
The input array won't violate no-adjacent-flowers rule.
The input array size is in the range of [1, 20000].
n is a non-negative integer which won't exceed the input array size.

* 663 Sum of Square numbers :Math:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/sum-of-square-numbers/description/][leetcode]]
:END:
** Problem
Given a non-negative integer c, your task is to decide whether there're two integers a and b such that a2 + b2 = c.

Example 1:
#+BEGIN_EXAMPLE
Input: 50
Output: True
Explanation: 1 * 1 + 2 * 2 = 5
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: 3
Output: False
#+END_EXAMPLE
* 665 Non-decreasing Array :Array:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/non-decreasing-array/description/][leetcode]]
:END:
** Problem
Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element.

We define an array is non-decreasing if nums[i] <= nums[i + 1] holds for every i (0-based) such that (0 <= i <= n - 2).


Example 1:
#+BEGIN_EXAMPLE
Input: nums = [4,2,3]
Output: true
Explanation: You could modify the first 4 to 1 to get a non-decreasing array.
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: nums = [4,2,1]
Output: false
Explanation: You can't get a non-decreasing array by modify at most one element.
#+END_EXAMPLE

*Constraints:*

- 1 <= n <= 10 ^ 4
- - 10 ^ 5 <= nums[i] <= 10 ^ 5
* 680 Valid Palindrome II :String:TwoPointers:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/valid-palindrome-ii/submissions/][leetcode]]
:END:
** Problem
Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome.

Example 1:
#+BEGIN_EXAMPLE
Input: "aba"
Output: True
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: "abca"
Output: True
Explanation: You could delete the character 'c'.
#+END_EXAMPLE

*Note:*
The string will only contain lowercase characters a-z. The maximum length of the string is 50000.
