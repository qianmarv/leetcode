#+TITLE: Leetcode Problems
#+AUTHOR: Marvin
#+PROPERTY: LOGGING nil

* 001 Two Sum :Array:HashTable:
:PROPERTIES:
:Difficulty: Easy
:END:
** Problem

Given an array of integers, return *indices* of the two numbers such that they
add up to a specific target.

You may assume that each input would have *exactly* one solution, and you may
not use the same element twice.

*Example*
#+BEGIN_EXAMPLE
Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,

return [0, 1].
#+END_EXAMPLE

** Solution
*** Brute Force
We can easily have a quick solution based on brute force way - two level nested
loops.

Pseudo code:
1. Outer loop, record index as =i=
2. Innser loop, record index as =j=
   - compare =targe= and =nums[i]+nums[j]=
   - if equal, exit the loop, return =i= & =j=
   - else, continue the loop

The time complexity of the brute force way is O(n^2), which is not good.
*** Hashmap
We can then have an idea that there's no need for two loops, if we can have a
hashmap of the numbers, we just need one loop, with =target-currentNumber=, we
can immediately get the index of second number. We only need 2n as for time
complexity. The first time of loop is to build the hashmap, we then have the
second loop to compare the target and retrieve the indices.

Pseudo code:
1. First loop - build hashmap with key equal to number and value to index
2. Second loop - let =taget_num = target - nums[i]=, retrieve second index from
   the hashmap, if =map[target_numer]= exist, then return it as second index,
   else continue the loop.

The time complexity is O(n)

*** Improved Hashmap
We then come with the idea that there's no need to prebuid the hashmap, we could
combine the building of hashmap and search target within exact one loop, the
performance then could be further improved.

Pseudo code:
1. Build am empty hashmap =map=
2. Within the loop of nums
   - let =target_num = target - nums[i]=
   - Check if target-num exist in map, return indices if exist
   - if not, put current value and index into the map.

* 002 Add Two Numbers :LinkedList:
:PROPERTIES:
:Difficulty: Medium
:END:
** Problem

You are given two non-empty linked lists representing two non-negative integers.
The digits are stored in reverse order and each of their nodes contain a single
digit. Add the two numbers and return it as a linked list.


You may assume the two numbers do not contain any leading zero, except the
number 0 itself.

*Example*
#+BEGIN_EXAMPLE
Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)

Output: 7 -> 0 -> 8

Explanation: 342 + 465 = 807.
#+END_EXAMPLE

** Solution
This problem is relatively simply if you are familiar with the basic data
structure linked list.

Just need to visit two linked list, have them sum up, in the meantime, need to
care about whether one of the linked list is empty, and whether the sum in each
time is bigger than 9.
* 003 Longest Substring :String:TowPointers:
:PROPERTIES:
:Difficulty: Medium
:END:
** Problem
Given a string, find the length of the longest substring without repeating characters.
*Example 1*
#+BEGIN_EXAMPLE
Input: "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
#+END_EXAMPLE

*Example 2*
#+BEGIN_EXAMPLE
Input: "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
#+END_EXAMPLE

*Example 3*
#+BEGIN_EXAMPLE
Input: "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Note that the answer must be a substring, "pwke" is a subsequence and not a substring.
#+END_EXAMPLE

** Solution
A typical two pointer or slide window problem.
The algorithm describes in below:
1. Define front pointer fp at position 0, define back pointer bp at position 0.
2. Check whether next character of fp has repeat character between fp and bp.
3. If not, move fp forward; And back to step 2
4. If yes,
   - compare current string length with already saved maximum string, if
     exceeds, then save current string to maxmum string
   - move bp to next character of the repeat character
   - move fp to next character, and back to step 2

The tricky part is how to detect whether the next character is repeat between bp
and fp, we could build a hash map to store the characters between bp and fp with
its position, so that the check time is constant. In this case, the space
complexity is O(n) time complexity is n,
* 004 Median of Two Sorted Arrays :Array:BinarySearch:DivedAndConquer:
:PROPERTIES:
:Difficulty: Hard
:Link:     https://leetcode.com/problems/median-of-two-sorted-arrays/
:END:
** Problem
There are two sorted arrays nums1 and nums2 of size m and n respectively.

Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

You may assume nums1 and nums2 cannot be both empty.

*Example 1:*
#+BEGIN_EXAMPLE
nums1 = [1, 3]
nums2 = [2]

The median is 2.0
#+END_EXAMPLE

*Example 2:*
#+BEGIN_EXAMPLE
nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5
#+END_EXAMPLE

** Solution
The straight forward idea is to repeatly minus the divisor from dividend according to definition of division. It surely works, the time complexity is n(divisor/dividend).

We can, somehow, think about that with repeatly do the step of ~let sum=divide, do sum += sum~, we could accelarate the minus. The next question is how we count how many times we've done the minus, answer is we setup another synced stack to calculate the repeat double of *one*. So that when we finish the minus, we just need to check the stack of *one*, and sum all of them.

*Pseudo code*:
1. Build a two dimension array, the initial two values are 1 & divide.
2. Double previous two values via plus the same, compare the doubled divide stack with dividend.
3. If less than dividend then store it in next array position. Continue with step 2.
4. Else, compare current (before doubled) divide value, check if < dividend.
5. If Yes, divident -= current summed divide value, array backwards one, sum the index stack
6. Else, array backwards one and continue with step 3

With step 4 - 6, the loop end condition should be dividend < divide.
Exception Case:
1. Dividend and divisor could be negative
2. Could be overflow during calcualtion.

* 005 Longest Palindromic Substring
:PROPERTIES:
:Difficulty: Medium
:END:
** Problem
Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.
*Example 1*
#+BEGIN_EXAMPLE
Input: "babad"
Output: "bab"
Note: "aba" is also a valid answer.
#+END_EXAMPLE

*Example 2*
#+BEGIN_EXAMPLE
Input: "cbbd"
Output: "bb"
#+END_EXAMPLE

** Solution
* 006 ZigZag Conversion
:PROPERTIES:
:Difficulty: Medium
:END:
** Problem
The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

P   A   H   N
A P L S I I G
Y   I   R
And then read line by line: "PAHNAPLSIIGYIR"

Write the code that will take a string and make this conversion given a number of rows:

string convert(string s, int numRows);
*Example 1*
#+BEGIN_EXAMPLE
Input: s = "PAYPALISHIRING", numRows = 3
Output: "PAHNAPLSIIGYIR"
#+END_EXAMPLE

*Example 2*
#+BEGIN_EXAMPLE
Input: s = "PAYPALISHIRING", numRows = 4
Output: "PINALSIGYAHRPI"
Explanation:

P     I    N
A   L S  I G
Y A   H R
P     I
#+END_EXAMPLE


** Solution
* 007 Reverse Integer :Math:
:PROPERTIES:
:Difficulty: Easy
:END:
** Problem
Given a 32-bit signed integer, reverse digits of an integer.

*Example 1*
#+BEGIN_EXAMPLE
Input: 123
Output: 321
Example 2:
#+END_EXAMPLE

*Example 2*
#+BEGIN_EXAMPLE
Input: 120
Output: 21
#+END_EXAMPLE

Note:
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.
* 008 String to Integer (atoi)
:PROPERTIES:
:Difficulty: Medium
:END:
** Problem
Implement atoi which converts a string to an integer.

The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.

The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.

If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.

If no valid conversion could be performed, a zero value is returned.

*Note*:

Only the space character ' ' is considered as whitespace character.
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.

*Example 1*:
#+BEGIN_EXAMPLE
Input: "42"
Output: 42
#+END_EXAMPLE

*Example 2*:
#+BEGIN_EXAMPLE
Input: "   -42"
Output: -42
Explanation: The first non-whitespace character is '-', which is the minus sign.
             Then take as many numerical digits as possible, which gets 42.
#+END_EXAMPLE

*Example 3*:
#+BEGIN_EXAMPLE
Input: "4193 with words"
Output: 4193
Explanation: Conversion stops at digit '3' as the next character is not a numerical digit.
#+END_EXAMPLE

*Example 4*:
#+BEGIN_EXAMPLE
Input: "words and 987"
Output: 0
Explanation: The first non-whitespace character is 'w', which is not a numerical
             digit or a +/- sign. Therefore no valid conversion could be performed.
#+END_EXAMPLE

*Example 5*:
#+BEGIN_EXAMPLE
Input: "-91283472332"
Output: -2147483648
Explanation: The number "-91283472332" is out of the range of a 32-bit signed integer.
             Thefore INT_MIN (−231) is returned.
#+END_EXAMPLE
** Solution

* 009 Palindrome Number :Math:
:PROPERTIES:
:Difficulty: Easy
:END:
** Problem
Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.

*Example 1:*
#+BEGIN_EXAMPLE
Input: 121
Output: true
#+END_EXAMPLE

*Example 2:*
#+BEGIN_EXAMPLE
Input: -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
#+END_EXAMPLE

*Example 3:*
#+BEGIN_EXAMPLE
Input: 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.
#+END_EXAMPLE
** Solution
* 010 Regular Expression Matching :String:DP:Backtracking:
:PROPERTIES:
:Difficulty: Hard
:END:
** Problem
Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'.

'.' Matches any single character.
'*' Matches zero or more of the preceding element.
The matching should cover the entire input string (not partial).

Note:

s could be empty and contains only lowercase letters a-z.
p could be empty and contains only lowercase letters a-z, and characters like . or *.
Example 1:
#+BEGIN_EXAMPLE
Input:
s = "aa"
p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input:
s = "aa"
p = "a*"
Output: true
Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".
#+END_EXAMPLE

Example 3:
#+BEGIN_EXAMPLE
Input:
s = "ab"
p = ".*"
Output: true
Explanation: ".*" means "zero or more (*) of any character (.)".
#+END_EXAMPLE

Example 4:
#+BEGIN_EXAMPLE
Input:
s = "aab"
p = "c*a*b"
Output: true
Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches "aab".
#+END_EXAMPLE

Example 5:
#+BEGIN_EXAMPLE
Input:
s = "mississippi"
p = "mis*is*p*."
Output: false
#+END_EXAMPLE

** Solution

* 029 Divide Two Integers :BinarySearch:
:PROPERTIES:
:Difficulty: Medium
:END:
** Problem
Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.

Return the quotient after dividing dividend by divisor.

The integer division should truncate toward zero, which means losing its fractional part. For example, truncate(8.345) = 8 and truncate(-2.7335) = -2.
*Example 1*
#+BEGIN_EXAMPLE
Input: dividend = 10, divisor = 3
Output: 3
Explanation: 10/3 = truncate(3.33333..) = 3.
#+END_EXAMPLE

*Example 2*
#+BEGIN_EXAMPLE
Input: dividend = 7, divisor = -3
Output: -2
Explanation: 7/-3 = truncate(-2.33333..) = -2.
#+END_EXAMPLE

** Solution
* TODO 032 Longest Valid Parentheses :String:DP:
:PROPERTIES:
:Difficulty: Hard
:Link:    [[https://leetcode.com/problems/longest-valid-parentheses/][leetcode]]
:END:
** Problem
Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.

Example 1:
#+BEGIN_EXAMPLE
Input: "(()"
Output: 2
Explanation: The longest valid parentheses substring is "()"
#+END_EXAMPLE

Example 2:
#+BEGIN_EXAMPLE
Input: ")()())"
Output: 4
Explanation: The longest valid parentheses substring is "()()"
#+END_EXAMPLE

* 070 Climbing Stairs :DP:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/climbing-stairs/description/][leetcode]]
:END:
** Problem
You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

*Example 1:*
#+BEGIN_EXAMPLE
Input: 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
#+END_EXAMPLE

*Example 2:*
#+BEGIN_EXAMPLE
Input: 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
#+END_EXAMPLE

*Constraints*:

1 <= n <= 45
** Solution
Source code in [[file:070_Climbing_Stairs/Java/Solution.java::class Solution{][Java]].
* 143 Reorder List :LinkedList:
:PROPERTIES:
:Difficulty: Medium
:END:
:LOGBOOK:
CLOCK: [2020-07-04 Sat 15:24]--[2020-07-04 Sat 17:46] =>  2:22
CLOCK: [2020-07-04 Sat 10:38]--[2020-07-04 Sat 11:50] =>  1:12
:END:
** Problem
Given a singly linked list L: L0→L1→…→Ln-1→Ln,
reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…

You may not modify the values in the list's nodes, only nodes itself may be
changed.

** Example
#+BEGIN_EXAMPLE
Given 1->2->3->4, reorder it to 1->4->2->3.
#+END_EXAMPLE

#+BEGIN_EXAMPLE
Given 1->2->3->4->5, reorder it to 1->5->2->4->3.
#+END_EXAMPLE

** Solution
*** First Try
We first get a reversed linked list, and then we travel the two linked list in
the same time until the value meet (The middle value).
The time complexity will be 2n or O(n), space complexity will be n or O(n).

Question: how we know we should stop, or how shall we know it's middle value.
Answer: It's singly linked list, so we can simple compare with the value, value
from the natual linked list should always left than or equal than the reversed
order one, and at one point, they will meet with the same value, then should
stop the loop.

currL -> L0;
nextL -> L1;
currRL > Ln;

L0->Ln;
currL -> L1;
nextL -> Ln-1;
currRL -> L2;

Failed, reason is the assumption which the linked list is ordered is incorrect,
in this case, we can only do the count for the reverse part. That's quite ugly.
*** Second Try
For linked list, we have so called "fast-slow-pointer", which means we set two
points to do the travesal of the singly linked list, slow pointer goes
one step in one round, while fast pointer goes two steps in one round, so when
fast pointer reach the end, we could imagine that the slow pointer exactly
stopped in the middle of the list.

Second step is, start at the middle position (slow->next), we start to reverse
the list, by the end of this step, we have two list, one is the natual list
pointd by head, the other is reversed from tail pointed by tail.

Last step is to compose the new list with the two lists, it's pretty easy step
to go.
* 167 Two Sum II :Array:TwoPointers:
:PROPERTIES:
:Difficulty: Easy
:END:
** Problem
Given an array of integers that is already sorted in ascending order, find two
numbers such that they add up to a specific target number.

The function twoSum should return indices of the two numbers such that they add
up to the target, where index1 must be less than index2.

*Note*:
- Your returned answers (both index1 and index2) are not zero-based.
- You may assume that each input would have exactly one solution and you may not
  use the same element twice.

*Example 1*
#+BEGIN_EXAMPLE
Input: numbers = [2,7,11,15], target = 9

Output: [1,2]

Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.
#+END_EXAMPLE
** Solution
*** Binary Search
We could of course still use the hasmap solution, which has both time and space
complexity of ~O(n)~. However, since the array is sorted, with the keyword
~sorted~, binary search jump into my mind. In this case, time complexity would
be O(n*log(n)), which is worse, but there's no extra space needed.

Pseudo Code:
#+BEGIN_EXAMPLE
1. Loop the array =numbers= with index =i=:
   - let =y=target-numbers[i]=
   - Do binary search of =y= on =numbers= (low = i)
   - If found, return [i+1,j+1]
#+END_EXAMPLE
*** Two Pointers
Apparently, ~O(n*logn)~ seems is not a good solution. We then can think
something of ~quick sort~, which uses two points, we can adapt the same idea
with keeping no extra space used but lowered the time complexity to ~O(n)~.

Pseudo Code:
#+BEGIN_EXAMPLE
1. Put the =lo= pointer to 0 and =hi= pointer to =lengh-1=
2. Set =y=target-numbers[lo]=, compare and move =hi= until =y>=numbers[hi]=
3. If =y!=numbers[hi]=, move lo forward, and repeat step 2.
#+END_EXAMPLE
* 198 House Robber :DP:
:PROPERTIES:
:Difficulty: Easy
:Link:     [[https://leetcode.com/problems/house-robber/submissions/][leetcode]]
:END:
** Problem
You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.



*Example 1:*
#+BEGIN_EXAMPLE
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.
#+END_EXAMPLE

*Example 2:*
#+BEGIN_EXAMPLE
Input: nums = [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
             Total amount you can rob = 2 + 9 + 1 = 12.

#+END_EXAMPLE

*Constraints:*

0 <= nums.length <= 100
0 <= nums[i] <= 400
** Solution
* 213 House Robber II :DP:
:PROPERTIES:
:Difficulty: Medium
:Link:     [[https://leetcode.com/problems/house-robber-ii/description/][leetcode]]
:END:
** Problem
You are a professional robber planning to rob houses along a street. Each house
has a certain amount of money stashed. All houses at this place are arranged in
a circle. That means the first house is the neighbor of the last one. Meanwhile,
adjacent houses have security system connected and it will automatically contact
the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each
house, determine the maximum amount of money you can rob tonight without
alerting the police.

*Example 1:*
#+BEGIN_EXAMPLE
Input: [2,3,2]
Output: 3
Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),
             because they are adjacent houses.
#+END_EXAMPLE

*Example 2:*
#+BEGIN_EXAMPLE
Input: [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.
#+END_EXAMPLE

** Solution
Similar to Problem 198 House Robber, need additional consideration if the first
house is robbed or not.
* 445 Add Two Numbers II :LinkedList:
:PROPERTIES:
:Difficulty: Medium
:END:
** Problem
You are given two non-empty linked lists representing two non-negative
integers. The most significant digit comes first and each of their nodes contain
a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Follow up:
What if you cannot modify the input lists? In other words, reversing the lists is not allowed.

*Example 1*
#+BEGIN_EXAMPLE
Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 8 -> 0 -> 7
#+END_EXAMPLE
** Solution
One option would be reverse the two linked list, then we can follow the same solution as in problem [[*Solution][002 Add Two numbers]].
In this case, what we can do is the reverse of linked list. This is easy to do.


While the follow up says, we cannot reverse the list, so we need to figure other option. The similar function would be use a StackList.
