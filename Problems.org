#+TITLE: Leetcode Problems
#+AUTHOR: Marvin
#+PROPERTY: LOGGING nil

* 001 Two Sum :Array:HashTable:
:PROPERTIES:
:Difficulty: Easy
:END:
** Problem

Given an array of integers, return *indices* of the two numbers such that they
add up to a specific target.

You may assume that each input would have *exactly* one solution, and you may
not use the same element twice.

** Example
#+BEGIN_EXAMPLE
Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,

return [0, 1].
#+END_EXAMPLE

** Solution
*** Brute Force
We can easily have a quick solution based on brute force way - two level nested
loops.

Pseudo code:
1. Outer loop, record index as =i=
2. Innser loop, record index as =j=
   - compare =targe= and =nums[i]+nums[j]=
   - if equal, exit the loop, return =i= & =j=
   - else, continue the loop

The time complexity of the brute force way is O(n^2), which is not good.
*** Hashmap
We can then have an idea that there's no need for two loops, if we can have a
hashmap of the numbers, we just need one loop, with =target-currentNumber=, we
can immediately get the index of second number. We only need 2n as for time
complexity. The first time of loop is to build the hashmap, we then have the
second loop to compare the target and retrieve the indices.

Pseudo code:
1. First loop - build hashmap with key equal to number and value to index
2. Second loop - let =taget_num = target - nums[i]=, retrieve second index from
   the hashmap, if =map[target_numer]= exist, then return it as second index,
   else continue the loop.

The time complexity is O(n)

*** Improved Hashmap
We then come with the idea that there's no need to prebuid the hashmap, we could
combine the building of hashmap and search target within exact one loop, the
performance then could be further improved.

Pseudo code:
1. Build am empty hashmap =map=
2. Within the loop of nums
   - let =target_num = target - nums[i]=
   - Check if target-num exist in map, return indices if exist
   - if not, put current value and index into the map.

* 002 Add Two Numbers :LinkedList:
:PROPERTIES:
:Difficulty: Medium
:END:
** Problem

You are given two non-empty linked lists representing two non-negative integers.
The digits are stored in reverse order and each of their nodes contain a single
digit. Add the two numbers and return it as a linked list.


You may assume the two numbers do not contain any leading zero, except the
number 0 itself.

** Example
#+BEGIN_EXAMPLE
Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)

Output: 7 -> 0 -> 8

Explanation: 342 + 465 = 807.
#+END_EXAMPLE

** Solution
This problem is relatively simply if you are familiar with the basic data
structure linked list.

Just need to visit two linked list, have them sum up, in the meantime, need to
care about whether one of the linked list is empty, and whether the sum in each
time is bigger than 9.
* TODO 003 Longest Substring :String:TowPointers:
:PROPERTIES:
:Difficulty: Medium
:END:
** Problem
Given a string, find the length of the longest substring without repeating characters.
** Example
#+BEGIN_EXAMPLE
Input: "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
#+END_EXAMPLE

#+BEGIN_EXAMPLE
Input: "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
#+END_EXAMPLE

#+BEGIN_EXAMPLE
Input: "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Note that the answer must be a substring, "pwke" is a subsequence and not a substring.
#+END_EXAMPLE

** Solution
* 143 Reorder List :LinkedList:
:PROPERTIES:
:Difficulty: Medium
:END:
:LOGBOOK:
CLOCK: [2020-07-04 Sat 15:24]--[2020-07-04 Sat 17:46] =>  2:22
CLOCK: [2020-07-04 Sat 10:38]--[2020-07-04 Sat 11:50] =>  1:12
:END:
** Problem
Given a singly linked list L: L0→L1→…→Ln-1→Ln,
reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…

You may not modify the values in the list's nodes, only nodes itself may be
changed.

** Example
#+BEGIN_EXAMPLE
Given 1->2->3->4, reorder it to 1->4->2->3.
#+END_EXAMPLE

#+BEGIN_EXAMPLE
Given 1->2->3->4->5, reorder it to 1->5->2->4->3.
#+END_EXAMPLE


** Solution
*** First Try
We first get a reversed linked list, and then we travel the two linked list in
the same time until the value meet (The middle value).
The time complexity will be 2n or O(n), space complexity will be n or O(n).

Question: how we know we should stop, or how shall we know it's middle value.
Answer: It's singly linked list, so we can simple compare with the value, value
from the natual linked list should always left than or equal than the reversed
order one, and at one point, they will meet with the same value, then should
stop the loop.

currL -> L0;
nextL -> L1;
currRL > Ln;

L0->Ln;
currL -> L1;
nextL -> Ln-1;
currRL -> L2;

Failed, reason is the assumption which the linked list is ordered is incorrect,
in this case, we can only do the count for the reverse part. That's quite ugly.
*** Second Try
For linked list, we have so called "fast-slow-pointer", which means we set two
points to do the travesal of the singly linked list, slow pointer goes
one step in one round, while fast pointer goes two steps in one round, so when
fast pointer reach the end, we could imagine that the slow pointer exactly
stopped in the middle of the list.

Second step is, start at the middle position (slow->next), we start to reverse
the list, by the end of this step, we have two list, one is the natual list
pointd by head, the other is reversed from tail pointed by tail.

Last step is to compose the new list with the two lists, it's pretty easy step
to go.
* 167 Two Sum II :Array:TwoPointers:
:PROPERTIES:
:Difficulty: Easy
:END:
** Problem
Given an array of integers that is already sorted in ascending order, find two
numbers such that they add up to a specific target number.

The function twoSum should return indices of the two numbers such that they add
up to the target, where index1 must be less than index2.

*Note*:
- Your returned answers (both index1 and index2) are not zero-based.
- You may assume that each input would have exactly one solution and you may not
  use the same element twice.

** Example

#+BEGIN_EXAMPLE
Input: numbers = [2,7,11,15], target = 9

Output: [1,2]

Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.
#+END_EXAMPLE

** Solution
*** Binary Search
We could of course still use the hasmap solution, which has both time and space
complexity of ~O(n)~. However, since the array is sorted, with the keyword
~sorted~, binary search jump into my mind. In this case, time complexity would
be O(n*log(n)), which is worse, but there's no extra space needed.

Pseudo Code:
#+BEGIN_EXAMPLE
1. Loop the array =numbers= with index =i=:
   - let =y=target-numbers[i]=
   - Do binary search of =y= on =numbers= (low = i)
   - If found, return [i+1,j+1]
#+END_EXAMPLE
*** Two Pointers
Apparently, ~O(n*logn)~ seems is not a good solution. We then can think
something of ~quick sort~, which uses two points, we can adapt the same idea
with keeping no extra space used but lowered the time complexity to ~O(n)~.

Pseudo Code:
#+BEGIN_EXAMPLE
1. Put the =lo= pointer to 0 and =hi= pointer to =lengh-1=
2. Set =y=target-numbers[lo]=, compare and move =hi= until =y>=numbers[hi]=
3. If =y!=numbers[hi]=, move lo forward, and repeat step 2.
#+END_EXAMPLE
* 445 Add Two Numbers II :LinkedList:
:PROPERTIES:
:Difficulty: Medium
:END:
** Problem
You are given two non-empty linked lists representing two non-negative
integers. The most significant digit comes first and each of their nodes contain
a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Follow up:
What if you cannot modify the input lists? In other words, reversing the lists is not allowed.

** Example
#+BEGIN_EXAMPLE
Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 8 -> 0 -> 7
#+END_EXAMPLE
** Solution
One option would be reverse the two linked list, then we can follow the same solution as in problem [[*Solution][002 Add Two numbers]].
In this case, what we can do is the reverse of linked list. This is easy to do.


While the follow up says, we cannot reverse the list, so we need to figure other option. The similar function would be use a StackList.
