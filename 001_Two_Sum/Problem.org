#+TITLE: 1. Two Sum

Rank: Easy

Given an array of integers, return *indices* of the two numbers such that they
add up to a specific target.

You may assume that each input would have *exactly* one solution, and you may
not use the same element twice.

* Example
#+BEGIN_QUOTE
Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
#+END_QUOTE

* Solution
** Brute Force
We can easily have a quick solution based on brute force way - two level nested
loops.

Pseudo code:
Assume the array as =array=, target as =target=
1. Outer loop, record index as =i=
2. Innser loop, record index as =j=
   - compare =targe= and =arrary[i]+array[j]=
   - if equal, exit the loop, return =i= & =j=
   - else, continue the loop

The time complexity of the brute force way is O(n^2), which is not good.
** Hash map
We can then have an idea that there's no need for two loops, if we can have a
hash map of the numbers, we just need one loop, with =target-currentNumber=, we
can immediately get the index of second number. We only need 2n as for time
complexity. The first time of loop is to build the hash map, we then have the
second loop to compare the target and retrieve the indices.

Pseudo code:
Assume the array as =array=, target as =target=
1. First loop - build hash map with key equal to number and value to index
2. Second loop - let taget_num = target - arrary[i], retrieve second index from
   the hash map, if map[target_numer] exist, then return it as second index,
   else continue the loop.

The time complexity is O(n)
