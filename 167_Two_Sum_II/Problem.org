#+TITLE: 167. Two Sum II - Input array is sorted

Rank ~Easy~

Given an array of integers that is already sorted in ascending order, find two
numbers such that they add up to a specific target number.

The function twoSum should return indices of the two numbers such that they add
up to the target, where index1 must be less than index2.

*Note*:
- Your returned answers (both index1 and index2) are not zero-based.
- You may assume that each input would have exactly one solution and you may not
  use the same element twice.

* Example:

#+BEGIN_QUOTE
Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.
#+END_QUOTE

* Solution
** Binary Search
We could of course still use the hasmap solution, which has both time and space
complexity of ~O(n)~. However, since the array is sorted, with the keyword
~sorted~, binary search jump into my mind. In this case, time complexity would
be O(n*log(n)), which is worse, but there's no extra space needed.

Pseudo Code:
#+BEGIN_QUOTE
1. Loop the array =numbers= with index =i=:
   - let =y=target-numbers[i]=
   - Do binary search of =y= on =numbers= (low = i)
   - If found, return [i+1,j+1]
#+END_QUOTE
** Two Pointers
Apparently, ~O(n*logn)~ seems is not a good solution. We then can think
something of ~quick sort~, which uses two points, we can adapt the same idea
with keeping no extra space used but lowered the time complexity to ~O(n)~.

Pseudo Code:
#+BEGIN_QUOTE
1. Put the =lo= pointer to 0 and =hi= pointer to =lengh-1=
2. Set =y=target-numbers[lo]=, compare and move =hi= until =y>=numbers[hi]=
3. If =y!=numbers[hi]=, move lo forward, and repeat step 2.
#+END_QUOTE
